% ----------------------------- BASI DEL LINGUAGGIO ----------------------------------

\chapter{Basi del Linguaggio}

%TODO: Sistemare il codice per rispettare le convenzioni del linguaggio.

%TODO: specificare che i termini subclass e superclass sono tipici di Java, non necessariamente del C++. 

%TODO: <limits>?

%TODO: L'stringa di testo' vuol dire wchar_t (extended character set) che a differenza di una normale stringa richiede 16 bits di memorizzazione.

%TODO: prefissi: 0x o 0X: esadecimale, 0: ottale, 0b o 0B: binario.
%TODO: suffissi: unisgned int: u alla fine, long int: l o L, unsigned long int: ul o UL, long long int: ll o LL, unsigned long long: ull o ULL.

%TODO: std::string_view

%TODO: #pragma once vs #ifndef #define #endif

%TODO: long long come data type e la L nei tipi long e la doppia L nei tipi long long LL

%TODO: La m_nomevariabile nelle variaibili membre della classe.

%TODO: Le direttive #include meglio mettere negli header .h o nei .cpp

% -------------------------- SECTION: INTRODUZIONE -----------------------------------

\section{Introduzione}

\enlargethispage{1\linewidth}

\textsf{\small Questa è una semplice e breve guida sul linguaggio C++. }\\

\textsf{\small Non insegna a programmare,
semplicemente è una collezione di frammenti di codice e spiegazioni delle sintassi
del linguaggio e alcune accortezze e good practices.}

\textsf{\small Questa è una guida per chi ha già familiarità con altri linguaggi di programmazione, come Java, C\# e vorrebbe avvicinarsi al C++.}\\

\textsf{\small Questa guida volge attorno alla versione C++17, ma vedremo anche alcuni concetti di C++20.
Mentre, l'ultima preview mostrata è stata quella del C++23.}\\

%TODO: aggiungere che questa non è una narrazione, ma è più un esporre, mostrare i vari componenti del linguaggio, a volte anche con esempi banali, ma chiari. (credo di averlo già detto nella parte "è una collezione di frammenti di codice ...")

% -------------------------- SECTION: LINGUAGGIO -------------------------------------

\section{Linguaggio}

\textsf{\small Il C++ è un linguaggio di programmazione general purpose nato nel 1983 da Bjarne Stroustrup nei Bell Labs come evoluzione del C.}\\

\textsf{\small Il nome del linguaggio deriva dal C, ma con l'aggiunta dell'operatore ++ che nel C serve per incrementare di 1. Il che stava a significare che il C++ è come il C, ma migliore, ovvero come suo successore, come sua evoluzione.}\\

% ---------------------------- SECTION: VERSIONI -------------------------------------

\newpage

\section{Versioni}

\textsf{\small Il C++ è un linguaggio che esiste da tanto e quindi nel tempo ha ricevuto diversi aggiornamenti, di seguito una lista delle versioni del linguaggio: }\\

\textsf{\small Il numero affianco a \textbf{C++} è l'anno in cui è uscita la versione.} \\

\begin{itemize}
	\item \textsf{\small \textbf{C++98/03}}
	\begin{itemize}
		\item \textsf{\small \emph{Nuove features} : RTTI, covariant return types, cast operators, mutable, bool, declarations in conditions, template instantiations, member templates, export}
		\item \textsf{\small \emph{Aggiunte alle librerie} : locales, bitset, valarray, auto\_ptr, templatized string, I/O streams, e complex numbers.}
		\item \textsf{\small \emph{Basate sul STL} :  containers, algorithms, iterators, function objects}
	\end{itemize}
	\item \textsf{\small \textbf{C++11}}
	\begin{itemize}
		\item \textsf{\small Grosso numero di cambiamenti alle pratiche standard già esistenti e miglioramenti all'astrazione disponibile per i programmatori.}
		\item \textsf{\small Numeri in virgola mobile dal IEEE 754: std::decimal::decimal32, \\ std::decimal::decimal64, eccetera.} %TR1 (Technical Report 1)
		\item \textsf{\small Fondata la \emph{The Standard C++ Foundation}.}
	\end{itemize}
	\item \textsf{\small \textbf{C++14}}
	\begin{itemize}
		\item \textsf{\small \emph{Nuove features} : variable templates, generic lambdas, lambda init-capture, new/delete elision,relaxed restrictions on constexpr functions, binary literals, digit separators, return type deduction for functions, aggregate classes with default non-static member initializers.}
		\item \textsf{\small \emph{Nuove features delle librerie} : std::make\_unique
			std::shared\_timed\_mutex and std::shared\_lock, std::integer\_sequence, std::exchange, std::quoted, e molti altri piccoli miglioramenti alle librerie già presenti, come: two-range overloads for some algorithms, type alias versions of type traits, user-defined literals for basic\_string, duration and complex, eccetera.}
		\item \textsf{\small Altre estensioni alle librerie.}
	\end{itemize}
	\item \textsf{\small \textbf{C++17}}
	\begin{itemize}
		\item \textsf{\small \emph{Nuove features} : fold-expressions, class template argument deduction, non-type template parameters declared with auto, compile-time if constexpr, inline variables, structured bindings, initializers for if and switch, u8 character literal, simplified nested namespaces, using-declaration declaring multiple names, made noexcept part of type system, new order of evaluation rules, guaranteed copy elision, temporary materialization, lambda capture of *this, constexpr lambda, gli attributi dei namespaces non devono essere ripetuti, nuovi attributi: [[fallthrough]], [[maybe\_unused]], [[nodiscard]], \_\_has\_include}
		\item \textsf{\small \emph{Nuovi files di intestazione} : <any>, <charconv>, <execution>, <filesystem>, <memory\_resource>, <optional>, <string\_view>, <variant>}
		\item \textsf{\small Ulteriori funzionalità nelle librerie, estensioni, rimozioni e deprecazione di altre funzionalità.}
	\end{itemize}
	\item \textsf{\small \textbf{C++20}}
	\begin{itemize}
		\item \textsf{\small \emph{Nuove features} : Feature test macros, 3-way comparison operator <=> and operator==() = default, designated initializers, init-statements and initializers in range-for, char8\_t, Nuovi attributi: [[no\_unique\_address]], [[likely]], [[unlikely]], pack-expansions in lambda init-captures, removed the requirement to use typename to disambiguate types in many, contexts, consteval, constinit, further relaxed constexpr, signed integers are 2's complement, aggregate initialization using parentheses, Coroutines, Modules, Constraints and concepts, Abbreviated function templates, DR: array new can deduce array size}
		\item \textsf{\small \emph{Nuovi headers} : <concepts>, <coroutine>, <compare>, <version>, <source\_location>, <format>, <span>, <ranges>, <bit>, <numbers>, <syncstream>, Per il supporto della libreria dei threads: <stop\_token>, <semaphore>, <latch>, <barrier>}
		\item \textsf{\small Ulteriori funzionalità alle librerie.}
	\end{itemize}
	\item \textsf{\small \textbf{C++23}} %TODO: aggiungere quando uscirà.
	%\begin{itemize}
		%\item \textsf{\small }
		%\item \textsf{\small }
		%\item \textsf{\small }
	%\end{itemize}
\end{itemize}

\textsf{\small Per determinare quale standard del linguaggio il compilatore sta utilizzando usufruiamo della macro: \textbf{\_\_cpluscplus} e la stampiamo a schermata.} \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/versions_new_in_libraries.png}
	\caption{Versioni}
	\label{fig:versions_new_in_libraries}
\end{figure}

% -------------------------- SECTION: PREPROCESSOR -----------------------------------

\newpage

\section{Preprocessor}

\textsf{\small Il \textbf{preprocessore} è composto da delle direttive che devono essere preprocessate dal compilatore prima dell'effettiva compilazione.} \\

\textsf{\small Per esempio di includere una libreria standard del linguaggio.} \\

\textsf{\small Le direttive del preprocessore iniziano con il carattere \textbf{\#}.} \\

\begin{lstlisting}
	// Con la direttiva \#include diciamo al preprocessore di includere questo file
	// che in questo caso si tratta della libreria standard per l'input ed output
	// del C++
	#include <iostream> 
\end{lstlisting}

% -------------------------- SECTION: COMPILATORE ------------------------------------

\section{Compilatore}

\textsf{\small Il C++ è un linguaggio di programmazione, di solito, implementato tramite un \textbf{compilatore} (un \emph{traduttore} che converte il \emph{codice sorgente} in \emph{codice macchina} object byte code) invece di un \textbf{interprete} (che esegue il direttamente il codice sorgente).} \\

% -------------------------- SECTION: LINKER -----------------------------------------

\section{Linker}

\textsf{\small Se il compilatore traduce il codice sorgente, il \textbf{linker} si occupa di risolvere le referenze ad altri files, per esempio all'inclusione di librerie standard del linguaggio. Quindi il linker linka i files che servono al codice per essere eseguito (che dopo la compilazione sarà probabilmente diventato un .OBJ).} \\

%TODO: + immagini.

% -------------------------- SECTION: RUNTIME VS COMPILE TIME ------------------------

\section{Runtime Vs Compile time}

\textsf{\small \textbf{Runtime} sono le istruzioni di codice che vengono eseguite mentre il tuo programma è in esecuzione.} \\

\textsf{\small \textbf{Compile time} sono le istruzioni che vengono tradotte dal compilatore nel momento della compilazione.} \\

% -------------------------- SECTION: C VS C++ ---------------------------------------

\newpage

\section{C vs C++}

\begin{longtable}{|c|c|}
	\hline
	\textbf{C} & \textbf{C++} \\
	\hline
	\endhead
	%\endfoot
	\textsf{\small Sviluppato da Dennis Ritchie } & \textsf{\small Sviluppato da Bjarne Stroustrup } \\
	\textsf{\small tra gli anni 1969 e 1973 agli AT\&T Bell Labs.} & \textsf{\small tra il 1979 ed il 1983.} \\
	\hline
	\textsf{\small Non supporta il polimorfismo,  } & \textsf{\small Supporta polimorfismo,  } \\
	\textsf{\small incapsulazione, ereditarietà} & \textsf{\small incapsulazione ed ereditarietà} \\
	\textsf{\small  il che significa che il C} & \textsf{\small il che significa} \\
	\textsf{\small non supporta la} & \textsf{\small  che è un linguaggio} \\
	\textsf{\small programmazione ad oggetti.} & \textsf{\small  di programmazione ad oggetti.} \\
	\hline
	\textsf{\small C è un sottoinsieme del C++.} & \textsf{\small Il C++ è un sovrainsieme del C.} \\
	\hline
	\textsf{\small Il C contiene 32 keywords.} & \textsf{\small Il C++ 63 keywords.} \\
	\hline
	\textsf{\small Il C supporta  } & \textsf{\small Il C++ è un ibrido, } \\
	\textsf{\small la programmazione } & \textsf{\small supporta sia la } \\
	\textsf{\small procedurale.} & \textsf{\small programmazione procedurale} \\
	\textsf{\small } & \textsf{\small sia i paradigmi della} \\
	\textsf{\small } & \textsf{\small programmazione ad oggetti.} \\
	\hline
	\textsf{\small Dati e funzioni sono separati} & \textsf{\small Dati e funzioni sono} \\
	\textsf{\small perché è un linguaggio} & \textsf{\small incapsulati in forma} \\
	\textsf{\small di programmazione procedurale.} & \textsf{\small di un oggetto.} \\
	\hline
	\textsf{\small Non supporta } & \textsf{\small I dati sono incapsulati } \\
	\textsf{\small l'information hiding.} & \textsf{\small per garantire che } \\
	\textsf{\small } & \textsf{\small vengano usati come inteso.} \\
	\hline
	\textsf{\small Tipi incorporati sono supportati} & \textsf{\small Tipi incorporati e tipi definiti} \\
	\textsf{\small dal C. (typedef).} & \textsf{\small dall'utente sono supportati.} \\
	\hline
	\textsf{\small Basata sulle funzioni perché} & \textsf{\small Basata sugli oggetti perché} \\
	\textsf{\small è un linguaggio procedurale.} & \textsf{\small è un linguaggio ad oggetti.} \\
	\hline
	\textsf{\small L'overloading delle funzioni e} & \textsf{\small L'overloading delle funzioni e} \\
	\textsf{\small degli operatori non è supportato.} & \textsf{\small degli operatori è supportato.} \\
	\hline
	\textsf{\small Non si possono definire funzioni} & \textsf{\small Si possono definire funzioni} \\
	\textsf{\small dentro le strutture.} & \textsf{\small dentro le strutture.} \\
	\hline
	\textsf{\small Namespaces non esistono in C.} & \textsf{\small Namespace sono presenti in C++.} \\
	\textsf{\small File header di input ed output} & \textsf{\small File header di input ed output} \\
	\textsf{\small in C è stdio.h.} & \textsf{\small in C++ è iostream.} \\
	\hline
	\textsf{\small Le variabili di referenza } & \textsf{\small Le variabili di referenza } \\
	\textsf{\small non sono supportate.} & \textsf{\small sono supportate.} \\
	\hline
	\textsf{\small Le funzioni virtual e} & \textsf{\small Le funzioni virtual e} \\
	\textsf{\small friends } & \textsf{\small friends } \\
	\textsf{\small non sono supportate.} & \textsf{\small sono supportate.} \\
	\hline
	\textsf{\small Non supporta l'ereditarietà.} & \textsf{\small Supporta l'ereditarietà.} \\
	\hline
	\textsf{\small Si concentra sulle funzioni} & \textsf{\small Si concentra sui dati} \\
	\textsf{\small più che sui dati.} & \textsf{\small più che sulle funzioni.} \\
	\hline
	\textsf{\small Fornisce malloc(), calloc(),} & \textsf{\small Fornisce gli operatori new e } \\
	\textsf{\small realloc() e free() per } & \textsf{\small delete (e altro) per  } \\
	\textsf{\small l'allocazione/deallocazione } & \textsf{\small l'allocazione/deallocazione } \\
	\textsf{\small  dinamica della memoria.} & \textsf{\small dinamica della memoria.} \\
	\hline
	\textsf{\small Supporto diretto per occuparsi} & \textsf{\small Supporto diretto per occuparsi} \\
	\textsf{\small delle eccezioni } & \textsf{\small delle eccezioni } \\
	\textsf{\small non è supportato.} & \textsf{\small è supportato.} \\
	\hline
	\textsf{\small scanf() e printf() sono usate} & \textsf{\small cin e cout sono usate} \\
	\textsf{\small per l'input/output in C.} & \textsf{\small per l'input/output in C++.} \\
	\hline
	\textsf{\small Le strutture in C non hanno} & \textsf{\small Le strutture in C++ hanno} \\
	\textsf{\small modificatori d'accesso.} & \textsf{\small modificatori d'accesso.} \\
	\hline
\end{longtable}

% ---------------------------- SECTION: KEYWORDS -------------------------------------

\section{Keywords}

\textsf{\small Il C++ presenta oltre 60+ \textbf{keywords}, ovvero \emph{parole chiavi} del linguaggio.} \\

\textsf{\small Le \textbf{keywords} sono delle parole riservate che hanno speciali funzionalità associate ad esse e sono già definite dal compilatore. Non si possono usare queste \emph{parole chiavi} come identificatori, come nomi delle variabili, ecc.} \\

\textsf{\small Di seguito, un'immagine di parte delle \textbf{keywords} del linguaggio: } \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/keywords2.png}
	%\caption{Keywords del Linguaggio}
	\label{fig:keywords}
\end{figure}

% -------------------------- SECTION: TIPI DI DATI -----------------------------------

\newpage

\section{Tipi di Dati}

%\verb!C++! % modo per scrivere C++

\textsf{\small Il C++ possiede diverse tipologie di memorizzazione dei dati: }\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/data_types_table.png}
	\caption{Tabelle dei tipi}
	\label{fig:data_types}
\end{figure}

\textsf{\small E dei wrappers sui tipi \textbf{unsigned} (ovvero senza segno, ovvero sempre e solo positivi), come: }\\

\begin{tabular}{cc}
	\color{myblue2}size\_t & \textbf{unsigned int} (se il compilatore è di 32 bit) \\
	 & \textbf{unsigned long long} (se il compilatore è da 64 bit) \\
	\color{myblue2}uint8\_t & \textbf{unsigned char} \\
	\color{myblue2}uint16\_t & \textbf{unsigned int}  \\
	\color{myblue2}uint32\_t & \textbf{unsigned long} \\ 
\end{tabular} \\

\textsf{\small E altri tipi di dati per lavorare sui caratteri e sulle stringhe: }\\

\begin{tabular}{cc}
	\color{myblue2}string & \textbf{una stringa di caratteri} (includere <string>) \\
	\color{myblue2}wchar\_t & \textbf{wide char} (per caratteri più grandi di 255) \\
\end{tabular}

\break

\textsf{\small Altri tipi di dati: } \\

\begin{tabular}{cc} %TODO: aggiungerne altri volendo.
	\color{myblue2}bool & Un booleano : o \textbf{0}, ovvero \textbf{FALSO/OFF} o \textbf{1}, ovvero \textbf{TRUE/ON} \\
	\color{myblue2}std::byte & \textbf{8 bit} (definito in <cstddef> header file) \\
	\color{myblue2}register &  \textbf{un registro} \\ 
	\color{myblue2} auto &  \textbf{trova la tipologia automaticamente} \\
\end{tabular}\\

\textsf{\small Esistono anche altri tipi, ma quelli qui riportati sono tra i più comuni.}\\

\begin{figure}[H] %TODO: remove?
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/data_types.jpg}
	\caption{Tipi di dati}
	\label{fig:data_types2}
\end{figure}

\subsection{Cast}

\textsf{\small \textbf{Definizione: } Il \textbf{Cast} è un'operazione che permette di cambiare la tipologia di una variabile o di una determinata operazione matematica.} 

\textsf{\small Ovviamente, questa operazione potrebbe portare ad una perdita di dati, in particolare, quando facciamo un cast da una tipologia più grande (che occupa più spazio, più bits) ad una più piccola (che occupa meno spazio, meno bits) perché quella piccola non ha lo stesso spazio di immagazzinamento di quella grande.} 

\textsf{\small Per esempio se si fa un cast da una tipologia a 32 bit ad una a 8 bit, ovviamente si perderanno dei dati, perchè quella da 8 non può contenere gli stessi dati di una da 32.} \\

\textsf{\small Per fare un cast bisogna mettere, prima dell'operazione, tra parentesi la tipologia a cui si vuole castare. Esempio: (float) 5 / 2 = 3.5} \\

\begin{lstlisting}
	// Primo esempio:
	
	int a = 7, b = 2;
	float c;
	
	c = a / b; // Output : 3
	
	c = (float) a / b; // Output : 3.5
	
	// Secondo esempio:
	
	double d = 36.9;
	float f = 22.2f;
	int x;
	
	x = (int) d; // Output : 36
	x = (int) f; // Output : 22
	
	// Ovviamente una variabile intera non può contenere i dati delle variabili con la virgola e quindi le informazioni sulla virgola vengono perse.
\end{lstlisting}

\textsf{\small Questo è un cast semplice o anche chiamato C-cast (ovvero un cast come nel C), ci sono altre forme di cast un po' più complesse che vedremo in un altro capitolo a pag.\textbf{\pageref{cast_types}}.} \\

\subsection{Importanza di scrivere la f nei float}

\textsf{\small Per i valori \textbf{float} (numeri in virgola mobile in singola precisione) sarà necessario oltre al numero inserire una \emph{f} dopo esso per indicare che questo è un numero in virgola mobile di tipo \textbf{float} (4 bytes, ovvero 32 bit).} \\

\textsf{\small Laddove noi non inserissimo la \emph{f} nel numero con la virgola, quello verrebbe considerato un numero in virgola mobile in doppia precisione di tipo \textbf{double} (che occupa 8 bytes, ovvero 64 bit).} \\

\begin{lstlisting}
	
	float x;
	
	float y = x / 2.0; // Se non si mette la f a quel 2.0, allora la variabile di tipo float y verrà promossa a double, perché 2.0 senza la f è un double.
	
	// Quindi dovremmo scrivere per restare con i float: `float y = x / 2.0f;`
\end{lstlisting}

% -------------------------- SECTION: COSTANTI ---------------------------------------

\newpage

\section{Costanti}

\textsf{\small Una costante è un valore che non cambia mai.}\\

\textsf{\small Ci sono diversi tipi di costanti e con significato diverso, per esempio \color{myblue2} const \normalcolor e \color{myblue2} constexpr. \normalcolor}\\

\subsection{const vs constexpr}

\begin{tabular}{|c|c|}
	\hline
	\textbf{const} & \textbf{constexpr} \\
	\hline
	\textsf{\small può essere composta da } & \textsf{\small deve essere conosciuta } \\
	\textsf{\small altre variabili a run-time} & \textsf{\small a compile-time} \\
	%\hline
	\textsf{\small può essere usata  } & \textsf{\small può essere usata  } \\
	\textsf{\small solo per} & \textsf{\small sia per member} \\
	\textsf{\small non-static member functions} & \textsf{\small e non-member functions} \\
	\textsf{\small } & \textsf{\small e anche costruttori} \\
	\hline
\end{tabular}\break

\subsection{static}

\subsubsection{Variabili statiche}

\textsf{\small Viene allocata per l'intera durata del programma. Anche se la funzione è chiamata molteplici volte, lo spazio allocato per la variabile statica è allocato una volta sola.} \\

\subsubsection{Membri statici delle classi} %TODO: sistemare questa parte.

\centering\textbf{Istanze delle classi come statiche} \\

\textsf{\small I distruttori (funzioni che rimuovo l'allocazione di memoria di un oggetto classe) vengono invocati soltanto dopo la fine del main (funzione principale da cui parte tutto il programma).} \break

\centering\textbf{Funzioni statiche in una classe} \\

\textsf{\small Queste possono soltanto accedere a dati statici o altre funzioni statiche.} \\

\subsection{static const}

\textsf{\small Per quanto riguarda \color{myblue2} static const \normalcolor possono ottenere un valore a compile time o a runtime, proprio come \color{myblue2} const, \normalcolor ma solo accessibili nella data funzione/classe.}\\

\subsection{static constexpr}

%TODO: scrivere qualcosa su static constexpr

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/constexpr_e_const_differenze.png}
	\caption{Tipi di costanti}
	\label{fig:constants}
\end{figure}

% -------------------------- SECTION: ARRAYS E MATRICI -------------------------------

\section{Arrays e Matrici}

\subsection{Arrays}

\textsf{\small \textbf{Definizione: } Gli array sono dei contenitori di dati, una collezione di dati dello stesso tipo.} \\

\textsf{\small Il primo elemento di un array, come qualsiasi altra cosa in informatica è l'elemento 0, \textbf{non} l'elemento 1.}\\

\textsf{\small Quindi l'elemento di indice 0 è il primo elemento, quello di indice 1 è il secondo, quello di indice 2 è il terzo e cosi via..} \\

\begin{lstlisting}[language=C++]
	// tipologia nomeDelArray[ spazioOccupato ];
	
	double dArray[3];
	
	// Qui potremmo usare un loop per definire questi elementi, 
	// ma li vedremo dopo.
	dArray[0] = 12.4;
	dArray[1] = 37.9;
	dArray[2] = 19.1;
	
	// Possiamo assegnarli anche quando definiamo l'array.
	int array[5] = {7, 9, 12, 4, 11};
	
	// Potremmo anche non definire il size (spazio dell'array).
	int array2[] = {3, 6, 9};
	
	// Ma è raccomandabile usare dei contenitori come: std::vector 
	// oppure una lista.
	// Oppure dei puntatori.
	// Oppure degli smart pointers.
\end{lstlisting}

\subsection{Matrici}

\textsf{\small \textbf{Definizione: } Le matrici sono degli arrays organizzati su righe e colonne. Questo concetto è per una matrice di 2-dimensioni. La si può pensare proprio come una tabella, formata da righe e da colonne.} \\

\begin{lstlisting}
	#include <iostream> 
	
	// <iostream> è un file di intestazione (header file) della libreria standard per poter lavorare sull'input e sull'output.
	
	// tipologia nome\_matrice [righe][colonne];
	
	int matrix[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}}
	
	for(int i = 0; i < 3; i++){
		for(int j = 0; j < 3; j++){
			std::cout << "elemento di riga " << i << " e colonna " << j << matrix[i][j] << std::endl;
		}
	}
\end{lstlisting}

\textsf{\small Ovviamente, come in matematica, è possibile eseguire varie operazioni sulle matrici, come: trasposizione, moltiplicazione, somma, sottrazione, ecc.} \\ 

% -------------------------- SECTION: OPERATORI ARITMETICI ---------------------------

\section{Operatori Aritmetici}

\textsf{\small \textbf{Definizione: } Gli operatori aritmetici permettono di eseguire qualsiasi operazione aritmetica.} \\

\begin{itemize}
	\item \textsf{\small \textbf{+} : somma.}
	\item \textsf{\small \textbf{-} : sottrazione.}
	\item \textsf{\small \textbf{*} : moltiplicazione.}
	\item \textsf{\small \textbf{/} : divisione.}
	\item \textsf{\small \textbf{\%} : modulo, restituisce il resto della divisione.}
\end{itemize}

\begin{lstlisting}
	int a = 8, b = 3;
	
	a + b; // Output : 11
	
	a - b; // Output : 5
	
	a * b; // Output : 24
	
	a / b; // Output : 2
	
	a % b; // Output : 2 (resto della divisione)
	
\end{lstlisting}

% -------------------------- SECTION: OPERATORI RELAZIONALI --------------------------

\section{Operatori Relazionali}

\textsf{\small \textbf{Definizione: } Gli operatori relazionali servono per controllare la relazione tra due operandi. } \\

\begin{itemize}
	\item \textsf{\small \textbf{==} : per l'equivalenza; controllare se due operandi sono uguali.}
	\item \textsf{\small \textbf{!=} : per controllare se due operandi non sono equivalenti.}
	\item \textsf{\small \textbf{>} : per controllare se un operando è maggiore di un altro}
	\item \textsf{\small \textbf{>=} : per controllare se un operando è maggiore o uguale all'altro.}
	\item \textsf{\small \textbf{<} : per controllare se un operando è minore di un altro.}
	\item \textsf{\small \textbf{<=} : per controllare se un operando è minore o uguale all'altro.}
\end{itemize}

\begin{lstlisting}
	int x = 5, y = 3;
	x == y // Output : FALSE
	x != y // Output : TRUE
	x > y // Output : TRUE
	x >= y // Output : TRUE
	x < y // Output : FALSE
	x <= y // Output : FALSE
	
\end{lstlisting}

% -------------------------- SECTION: OPERATORI BITWISE ------------------------------

\section{Operatori Bitwise}

\textsf{\small \textbf{Definizione: } Gli operatori bitwise servono per lavorare sui singoli bits di dati.} \\

\begin{itemize}
	\item \textsf{\small \textbf{\& (bitwise AND)} : permette di fare un AND bit a bit sui due operandi. Il risultato è 1 soltanto se entrambi sono 1.}
	\item \textsf{\small \textbf{| (bitwise OR)} : permette di fare un OR bit a bit su ogni bit dei due operandi. Il risultato è 1 se almeno uno dei due bits è a 1.}
	\item \textsf{\small \textbf{\textasciicircum  (bitwise XOR)} : permette di fare uno XOR bit a bit su ogni bit dei due operandi. Il risultato è 1 se i due bits sono differenti.}
	\item \textsf{\small \textbf{$<<$ (left shift)} : prende due numeri. Shifta a sinistra i bits del primo operando, il secondo operando decide di quanti bits si deve shiftare il primo.}
	\item \textsf{\small \textbf{$>>$ (right shift)} : prende due numeri. Shifta a destra i bits del primo operando, il secondo operando decide di quanti bits si deve shiftare il primo.}
	\item \textsf{\small \textbf{\textasciitilde (bitwise NOT)} : prende un numero ed inverte tutti i bits.}
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/bitwise_operators_truth_table.png}
	\caption{Tabella della verità delle operazioni bitwise.}
	\label{fig:bitwise_operators_truth_table}
\end{figure}

\begin{lstlisting}
	// a = 5 in binario è 00000101, b = 9 in binario è 00001001
	int a = 5, b = 9;
	
	a & b; // Output : 00000001
	
	a | b; // Output : 00001101
	
	a ^ b; // Output : 00001100
	
	~a; // Output : 11111010
	
	b << 1; // Output : 00010010
	
	b >> 1; // Output : 00000100
	
	
\end{lstlisting}

% ---------- SECTION: OPERATORI DI ASSEGNAMENTO E OPERATORI UNARI --------------------

\section{Operatori di Assegnamento e Operatori Unari}

\subsection{Operatori di Assegnamento}

\textsf{\small \textbf{Definizione: } Gli operatori di assegnamento sono usati per assegnare un valore alle variabili.} \\

\begin{itemize}
	\item \textsf{\small \textbf{=} : Operatore di assegnamento di un valore ad una variabile.}
	\item \textsf{\small \textbf{+=} : Combinazione di = e +, aggiunge l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{-=} : Combinazione di = e -, sottrae l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{*=} : Combinazione di = e *, moltiplica l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{/=} : Combinazione di = e /, divide l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{\%=} : Combinazione di = e \%, ottiene il resto dall'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{$<<$=} : Combinazione di = e $<<$, left shifta l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{$>>$=} : Combinazione di = e $>>$, right shifta l'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{\&=} : Combinazione di = e \&, bitwise AND sull'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{\textasciicircum =} : Combinazione di = e \textasciicircum, bitwise XOR sull'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{|=} : Combinazione di = e |, bitwise OR sull'operando di destra a quello di sinistra e lo assegna a quello di sinistra.}
	\item \textsf{\small \textbf{$<>$=} : Bitwise shift left/right assignment} 
\end{itemize}

\begin{lstlisting}
	int x = 5; // = è un operatore di assegnamento.
	int y;
	
	y += 3; // += è un operatore di assegnamento ed è la combinazione dell'operatore = e l'operatore +. Scrivere y += 3; è identico a scrivere y = y + 3; (ovvero y è uguale a se stesso + 3).
	
	y -= 2; // identico a y = y - 2;
	
	y *= 4; // identico a y = y * 4; (* è un per, oppure viene usato nei puntatori)
	
	y /= 6; // identico a y = y / 6;
	
\end{lstlisting}

\subsection{Operatori Unari}

\textsf{\small \textbf{Definizione: } Gli operatori unari operano su un operando per produrre un nuovo valore.} \\

\begin{itemize}
	\item \textsf{\small \textbf{-} : nega il valore dell'operando.}
	\item \textsf{\small \textbf{++nome\_variabile} : Incremento di 1 prefix, prima incrementa l'operando prima che venga eseguito.}
	\item \textsf{\small \textbf{nome\_variabile++} : Incremento postfix, il valore verrà incrementato dopo che è stato usato.}
	\item \textsf{\small \textbf{- -nome\_variabile} : Decremento di 1 prefix, decrementa l'operando prima che venga usato. }
	\item \textsf{\small \textbf{nome\_variabile- -} : Decremento postfix, il valore verrà decrementato dopo che è stato usato.}
	\item \textsf{\small \textbf{\&nome\_variabile} : prima di una variabile, restituisce l'indirizzo di memoria della variabile in questione. In questo caso, \textbf{NON} è l'operatore bitwise AND \&.}
	\item \textsf{\small \textbf{!nome\_variabile} : operatore not, inverte lo stato logico dell'operando. Se è TRUE allora lo modifica in FALSE, se è FALSE allora diventa TRUE.}
\end{itemize}

\begin{lstlisting}
	int x = 3;
	
	-x; // l'operatore - nega il valore dell'operando.
	
	++x; // identico a scrivere x = x + 1; Questo è chiamato incremento prefisso, perché: in questo modo il valore dell'operando verrà alterato prima che venga usato.
	
	x++; // identico a scrivere x = x + 1; L'operatore ++ incrementa di 1 il valore della variabile in questione. Questo è chiamato incremento postfisso perché: in questo modo il valore verrà modificato dopo che è stato usato.
	
	--x; // identico a scrivere x = x - 1; Come per il ++ questo è un decremento prefisso.
	
	x--; // identico a scrivere x = x - 1; Decrementa di 1 il valore della variabile in questione. Decremento post fisso.
	
	&x; // l'operatore \&, prima di una variabile, restituisce l'indirizzo di memoria in cui la variabile risiede.
	
	bool y = true;
	
	!y; // Output : y è false;  l'operatore ! (not) inverte lo stato logico dell'operando.
	
\end{lstlisting}

% -------------------------- SECTION: OPERATORI LOGICI -------------------------------

\section{Operatori Logici}

\textsf{\small \textbf{Definizione: } Gli operatori logici servono per combinare due o più condizioni. Il risultato di un'operazione degli operatori logici è un booleano TRUE (VERO) o FALSE (FALSO).} \\

\begin{itemize}
	\item \textsf{\small \textbf{\&\& (logical AND)} : restituisce vero se tutte le condizioni sono vere.}
	\item \textsf{\small \textbf{|| (logical OR)} : restituisce vero se almeno una delle condizioni è vera.}
	\item \textsf{\small \textbf{! (logical NOT)} : restituisce vero se la condizione è falsa e restituisce falso se la condizione è vera.}
	\item \textsf{\small \textbf{!\textasciitilde} : Logical negation/bitwise complement} 
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/logical_operators_truth_table.png}
	\caption{Tabella della verità degli operatori logici.}
	\label{fig:logical_operators_truth_table}
\end{figure}

\begin{lstlisting}
	int x = 3, y = 6, z = 9;
	
	(x > y) || (y != z); // Output : TRUE, perché anche se x > y è FALSA, y != z è VERA.
	
	(y > x) && (y < z); // Output : TRUE perché entrambe sono vere.
	
	!(x > 7); // Output : TRUE, perché x non è maggiore di 7, quindi è falsa, ma il not inverte e quindi essendo la condizione falsa, il not la inverte in VERA.
	
\end{lstlisting}

% -------------------------- SECTION: ALTRI OPERATORI --------------------------------

\section{Altri Operatori}

\textsf{\small Ci sono altri operatori come: } \\

\begin{itemize}
	\item \textsf{\small \textbf{sizeof} : è usato per ottenere lo spazio che occupa una variabile.}
	\item \textsf{\small \textbf{,} : la virgola è usata sia come operatore che come separatore. Valuta il primo operando e cancella il risultato, valuta il secondo operando e restituisce il suo valore.}
	\item \textsf{\small \textbf{Operatore Condizionale/Ternario} : condizione ? se vero esegui questo : se falso esegui questo.}
\end{itemize}

\begin{lstlisting}
	sizeof(char); // Output : 1
	sizeof(int); // Output : 4
	sizeof(float); // Output : 4
	sizeof(double); // Output : 8
	
	int a = 0;
	double d = 3.69;
	
	sizeof(a); // Output : 4
	sizeof(d); // Output : 4
	
	sizeof(a + d); // Output : 8
	
	int y = 2, x = 3; // Output : equivalente a int y = 2; int x = 3;
	
	x >= 0 ? "x è maggiore o uguale a 0" : "x è minore di 0"; // Output : "x è maggiore o uguale a 0".
\end{lstlisting}

% -------------------------- SECTION: IF STATEMENTS ----------------------------------

\newpage

\section{Condizione If}

\subsection{If|else if|else}

\textsf{\small \textbf{Definizione:} L'If statement permette di decidere se un certo blocco di codice verrà eseguito o no.} \\

\textsf{\small L'else statement permette di eseguire un altro blocco di codice, casomai la condizione nell'if statement sia falsa.} \\

\textsf{\small else if(condizione) statement permette di fare un'ulteriore controllo dopo al primo if statement. } \\

\subsection{Operatore Ternario}

\textsf{\small Un altro modo per valutare una condizione ed eseguire un codice è attraverso l'operatore ternario: condizione ? se è vera esegui questo : altrimenti esegui questo.} \\

\textsf{\small L'unica differenza con l'if è che si può eseguire una sola riga di codice sia nel caso la condizione sia vera sia falsa.} \\

\begin{lstlisting}
	#include <iostream>
	
	if(condizione)
	{
		// Se (if) la condizione è vera esegui questo blocco di codide.
	} else {
		// Altrimenti (else) esegui questo blocco di codice.
	}

	// Esempio: Cerchiamo il valore maggiore.
	int x = 5, y = 3;
	
	if(x > y)
	{
		std::cout << "x è maggiore di y" << std::endl;
	} 
	else if(x == y){
		std::cout << "x ed y sono uguali" << std::endl;
	}
	else {
		std::cout << "x è minore di y" << std::endl;
	}

	// Qui invece cerchiamo il valore minore.
	int a = 8, b = 7;
	int min;
	
	min = a < b ? a : b;
	
	std::cout << "Il valore minimo è: " << min << std::endl;
\end{lstlisting}

\textsf{\small Se la riga da eseguire è 1 sola, allora si possono anche omettere le parentesi graffe nell'if.} \\

\subsection{if constexpr}

%TODO: approfondire il concetto e spiegarlo meglio o passarlo al capitolo Concetti Intermedi.

\textsf{\small È possibile implementare un if statico sotto forma di \textbf{if constexpr} che valuta la condizione a \emph{tempo di compilazione} e solo un blocco verrà compilato.} \\

\begin{lstlisting}
	#include <iostream>
	
	int main()
	{
		const int a = 2, b = 3;
		if constexpr(a > b)
		{
			std::cout << a << " è maggiore di " << b << std::endl;
		} else {
			std::cout << a << " è minore di " << b << std::endl;
		}
	
		//Output: 2 è minore di 3
		return 0;
	}
\end{lstlisting}

\textsf{\small Un altro modo per fare un \emph{if statico} è quello di usare \emph{std::enable\_if}.} \\

\textsf{\small Questa espressione sarà utile nel \emph{template metaprogramming}.} \\

% -------------------------- SECTION: SWITCH -----------------------------------------

\section{Switch}

\subsection{Switch|Cases|Break}

\textsf{\small \textbf{Definizione: } Gli switch statements valutano una data espressione ed in base al valore di quella espressione, eseguono un determinato blocco di codice.} \\

\textsf{\small Le possibili espressioni che si possono mettere nello switch sono: }

\begin{itemize}
	\item \textsf{\small Un numero intero, \color{myblue2}int}
	\item \textsf{\small Un enumeratore, \color{myblue2}enum}
	\item \textsf{\small Un carattere, \color{myblue2}char \normalcolor che è un piccolo intero tra -128 e + 127.}
\end{itemize}

\textsf{\small Le varie scelte sono indicate nel \textbf{case}.} \\

\textsf{\small I cases son tutti collegati fra loro e quindi per far si che solo un blocco di codice venga eseguito utilizziamo la keyword \textbf{break} per poter uscire dallo switch una volta che il codice è stato eseguito.} 

\textsf{\small Se non mettessimo il \textbf{break} allora una volta eseguito un case, il codice che è sequenziale, eseguirebbe il case sotto. Possiamo evitare di metterlo se vogliamo che alcuni case eseguino lo stesso codice.} \\

\subsection{Default Case}

\textsf{\small Infine c'è un case \textbf{default} nel caso che il valore valutato non sia presente tra i case. Questo case è opzionale, quindi si può anche non includere.}

\textsf{\small Per il \textbf{default} non serve il \textbf{break} perchè è comunque l'ultimo case, però volendo lo si può sempre mettere.} \\

\begin{lstlisting}
	#include <iostream>
	
	int scelta = 3;
	
	switch(scelta){
		case 1:
			std::cout << "Scelta: 1" << std::endl;
			// Blocco di codice per il case 1.
			break;
		case 2:
			std::cout << "Scelta: 2" << std::endl;
			// Blocco di codice per il case 2.
			break;
		case 3:
			std::cout << "Scelta: 3" << std::endl;
			// Blocco di codice per il case 3.
			break;
		default:
			std::cout << "Nessuna scelta o scelta non prevista." << std::endl;
			// Blocco di codice per il default case.
			break;
	}
\end{lstlisting}

% -------------------------- SECTION: LOOPS ------------------------------------------

\newpage

\section{Loops}

\textsf{\small \textbf{Definizione: } I loops (cicli) ci permettono di ripetere un dato blocco di codice per un determinato o indeterminato numero di volte.} \\

\subsection{While}

\textsf{\small I while loops ci permettono di eseguire un ciclo quando non conosciamo esattamente il numero di iterazioni. } \\

\textsf{\small La condizione del while viene valutata, se possibile entra dentro al loop altrimenti lo salta ed esegue il codice dopo.}

\textsf{\small Ad ogni iterazione la condizione viene controllata, se vera il ciclo continua, se falsa il ciclo viene interrotto.} \\

\begin{lstlisting}
	#include <iostream>
	
	while(condizione){
		// Blocco di codice da eseguire.
	}

	int x = 3;
	
	while(x < 5){
		std::cout << "Ciao per la " << x << "a volta" << std::endl;
		x++; // indentico a x = x + 1
	}
\end{lstlisting}

\subsection{Do-While}

\textsf{\small Nel Do while rispetto al singolo while, si entra almeno una volta all'interno del ciclo, poi come nel while viene controllata la condizione e se vera il ciclo continua altrimenti verrà interrotto.} \\

\begin{lstlisting}
	#include <iostream>
	
	do{
		// Blocco di codice da eseguire.
	}while(condizione); // da notare il ; dopo il while.

	int x = 2;
	
	do{
		std::cout << "Hello World!" << std::endl;
		x++;
	}while(x < 1);
\end{lstlisting}

\subsection{Continue}

\textsf{\small La keyword \textbf{continue} è simile alla keyword \textbf{break}, ma invece di terminare l'esecuzione (del loop, dello switch, ecc.), passa alla prossima iterazione del loop.}\\

\begin{lstlisting}
	#include <iostream>
	
	int a = 5;
	do {
		if(a == 10){
			a++;
			continue;
		}
		std::cout << "Valore di a: " << a << std::endl;
		a++;
	} while( a < 20);
\end{lstlisting}

\subsection{goto}

\textsf{\small La keyword \textbf{goto} permette di fare un salto incondizionato verso una label (etichetta).}

\textsf{\small Potrebbe essere utile per uscire dai cicli annidati (nested loops).}

\textsf{\small L'uso del \textbf{goto} è scoraggiato ed è considerato una \emph{bad practice} perché porta a quello che è definito \emph{spaghetti code}, ovvero ad un codice destrutturato e difficile da mantenere.} \\

\begin{lstlisting}
	#include <iostream>
	
	int a = 10;
	
	LOOP:do {
		if( a == 15) {
			// skip the iteration.
			a = a + 1;
			goto LOOP;
		}
		std::cout << "value of a: " << a << std::endl;
		a = a + 1;
	} 
	while( a < 20 );
\end{lstlisting}

\subsection{For}

\textsf{\small Il for loop è composto da tre parti: l'inizializzazione della variabile contatore, la condizione, ed aggiornamento della variabile contatore. }

\textsf{\small A differenza del while loop, in questo conosciamo già a priori quanti cicli faremo.}

\textsf{\small Ad ogni iterazione del ciclo, la variabile contatore viene aggiornata.} \\

\begin{lstlisting}
	for(inizializzazione; condizione; aggiornamento variabile){
		// Codice da eseguire.
	}

	int n = 4;
	
	for(int i = 0; i < n; i++){
		// Codice da eseguire
	}
\end{lstlisting}

\subsection{Range-based for loop | Foreach}

\textsf{\small Questo loop è un po' più complicato e si avvale degli iteratori che verranno spiegati più avanti in un altro capitolo.} \\

\textsf{\small Vengono trattati nel capitolo \emph{Concetti Intermedi} a pag.\textbf{\pageref{foreach}}.} \\

\subsection{Cicli annidati}

\textsf{\small Si può inserire un loop dentro ad un altro loop (cicli annidati o nested loops).} \\

\subsection{Cicli Infiniti}

\textsf{\small Bisogna fare attenzione a non creare cicli infiniti, che come dice la parola vanno ad oltranza, rallentano e bloccano il programma.}\\

\begin{lstlisting}
	#include <iostream>
	
	for( ; ; ){
		std::cout << "Loop Infinito" << std::endl;
	}
\end{lstlisting}

% -------------------------- SECTION: ENUMS ------------------------------------------

\section{Enumeratori}

\textsf{\small \textbf{Definizione: } Gli enumeratori sono dei tipi di dati definiti dagli utenti e usati per assegnare nomi a delle costati intere, il che rende il codice chiaro da leggere.}

\textsf{\small Il primo elemento di un \textbf{enum} è di indice 0, a meno che non lo si cambi, se lo si cambia, di conseguenza, cambiano anche tutti gli altri sotto.} \\

\begin{lstlisting}
	#include <iostream>
	
	enum Days {Lunedi, Martedi, Mercoledi, Giovedi, Venerdi, Sabato, Domenica};
	Days day = Venerdi;
	
	if(day == Venerdi){
		std::cout << "Oggi è venerdi!" << std::endl;
	}
	
	enum Year {
		GENNAIO = 1,
		FEBBRAIO,
		MARZO,
		APRILE,
		MAGGIO,
		GIUGNO,
		LUGLIO,
		AGOSTO,
		SETTEMBRE,
		OTTOBRE,
		NOVEMBRE,
		DICEMBRE
	};

	Year mese = FEBBRAIO;
	std::cout << "Siamo nel " << mese << "o mese dell'anno" << std::endl;

	enum Colors {
		ROSSO,
		BLU,
		VERDE,
		GIALLO,
		ARANCIONE,
		GRIGIO,
		VIOLA,
		ROSA,
		NERO,
		BIANCO
	};	

	Colors colore = Colors.ARANCIONE;
	std::cout << "Colore di indice: " << colore << std::endl;
	
	// Per poter vedere il nome dell'enum e non il suo valore, bisogna utilizzare una mappa o uno switch o altro.
\end{lstlisting}

% -------------------------- SECTION: PUNTATORI --------------------------------------

\newpage

\section{Puntatori}

\textsf{\small \textbf{Definizione: } Un puntatore è una variabile che contiene l'indirizzo di memoria di un' altra variabile. Si può dire che questa variabile punta ad un' altra.} \\

\textsf{\small Per creare un puntatore usiamo l'operatore \textbf{*} che è lo stesso usato anche per la moltiplicazione.}

\textsf{\small Usiamo l'operatore \textbf{\&} (indirizzo) per ottenere l'indirizzo di una variabile.} 

\textsf{\small Per ottenere il valore della variabile a cui il puntatore punta usiamo l'operatore \textbf{*} (dereferenza).}\\

\begin{lstlisting}
	#include <iostream>
	
	int x = 5;
	int* ptr; // puntatore ad intero
	
	ptr = &x; // il puntatore ptr punta alla variabile x
	
	std::cout << var << std::endl; // Output : 5
	std::cout << ptr << std::endl; // Output : indirizzo di x
	std::cout << *ptr << std::endl; // Output : 5
\end{lstlisting}

\subsection{Aritmetica dei puntatori}

\textsf{\small Sui puntatori è possibile eseguire delle operazioni aritmetiche:} \\

\begin{itemize}
	\item \textsf{\small Icremento|Decremento di un puntatore.}
	\item \textsf{\small Addizione di un intero a un puntatore.}
	\item \textsf{\small Sottrazione di un intero a un puntatore.}
	\item \textsf{\small Sottrazione di due puntatori dello stesso tipo.}
\end{itemize}

\begin{lstlisting}
	#include <iostream>
	
	// Primo esempio
	#define MAX 3
	int var[MAX] = {3, 6, 9};
	int *ptr1, *ptr2;
	
	ptr1 = &var[MAX - 1];
	
	while ( ptr <= &var[MAX - 1] ) {
		std::cout << "Address of var[" << i << "] = ";
		std::cout << ptr << endl;
		
		std::cout << "Value of var[" << i << "] = ";
		std::cout << *ptr << endl;
		
		// point to the previous location
		ptr++;
		i++;
	}
	
	// Secondo esempio
	
	int x[10];
	int *p1, *p2;
	int i;
	
	p1 = &x[3]; // P1 punta a x[3]
	p2 = p1 + 2; // P2 punta a x[5]
	
	p1 += 6; // P1 punta ad x[9];
	
	p2 = p1 - 3; // P2 punta ad x[6];
	p1 -= 7; // P1 punta ad x[2];
	
	i = p2 - p1; // i : 6 - 2 = 4
	i = p1 - p2; // i : 2 - 6 = -4
\end{lstlisting}

\subsection{Puntatori a puntatori}

\textsf{\small Come esistono i puntatori ad una variabile, esistono anche dei puntatori ad altri puntatori.} \\

\textsf{\small Creiamo un puntatore ad un puntatore semplicemente aggiungendo un ulteriore * al singolo puntatore.}

\begin{lstlisting}
	#include <iostream>
	
	int var = 369;
	int *ptr;
	int **pptr;
	
	ptr = &var;
	
	pptr = &ptr;
	
	std::cout << "Valore di var: " << var << std::endl; // Output: Valore di var: 369
	std::cout << "Valore di *ptr: " << var << std::endl; // Output: Valore di *ptr: 369
	std::cout << "Valore di **pptr: " << var << std::endl; // Output: Valore di **pptr: 369
\end{lstlisting}

%TODO: volendo puntatori ad array.
%TODO: volendo puntatori a matrici.

% -------------------------- SECTION: REFERENCE --------------------------------------

\section{References}

\textsf{\small \textbf{Definizione: } Una reference è come un alias, ovvero un altro nome per una variabile che già esiste. Come i puntatori è implementata attraverso la memorizzazione dell'indirizzo di memoria della suddetta variabile.} \\

\textsf{\small Definiamo una reference attraverso l'operatore \textbf{\&} prima del nome della variabile.}

\textsf{\small Se facciamo qualcosa alla reference, all'alias, di conseguenza lo facciamo anche alla variabile a cui si riferisce.} \\

\begin{lstlisting}
	#include <iostream>
	
	int x = 10;
	
	int& ref = x; // Questa è una reference alla variabile x.
	
	ref = 20;
	std::cout << "x: " << x << std::endl; // Output : 20
	
	x = 30;
	std::cout << "ref: " << ref << std::endl; // Output : 30
\end{lstlisting}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/References.png}
	\caption{Reference}
	\label{fig:references1}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/References2.png}
	\caption{Reference}
	\label{fig:references2}
\end{figure}

\subsection{References vs Puntatori}

\begin{tabular}{|c|c|}
	\hline
	\textbf{Reference} & \textbf{Pointers} \\
	\hline
	\textsf{\small Riferiscono a una variabile } & \textsf{\small Memorizzano un indirizzo } \\
	\textsf{\small con un altro nome.} & \textsf{\small di una variabile.} \\
	\hline
	\textsf{\small Non possono avere un valore \color{myblue2}NULL \normalcolor.} & \textsf{\small Possono avere un valore \color{myblue2}NULL \normalcolor.} \\
	\hline
	\textsf{\small Deve essere inizializzata } & \textsf{\small Può anche non essere inizializzata } \\
	\textsf{\small alla dichiarazione.} & \textsf{\small alla dichiarazione.} \\
	\hline
	\textsf{\small Condivide la stessa memoria  } & \textsf{\small Ha un proprio spazio e } \\
	\textsf{\small con la variabile originale, } & \textsf{\small indirizzo di memoria } \\
	\textsf{\small ma prende anche dello spazio nello stack.} & \textsf{\small sullo stack.} \\
	\hline
	\textsf{\small Non può essere riassegnato.} & \textsf{\small Può essere riassegnato.} \\
	\hline
	\textsf{\small Hanno un solo livello di indirezione.} & \textsf{\small Si possono avere puntatori } \\
	\textsf{\small } & \textsf{\small a puntatori per livelli extra } \\
	\textsf{\small } & \textsf{\small di indirezione.} \\
	\hline
	\textsf{\small Non c'è la aritmetica delle references} & \textsf{\small C'è l'aritmetica dei puntatori.} \\
	\hline
	%\textsf{\small } & \textsf{\small } \\
	%\hline
\end{tabular}

\subsection{NULL vs nullptr}

\textsf{\small \textbf{NULL} portato dal C corrisponde semplicemente a 0 (è una macro) e non necessariamente ad un puntatore. Mentre \textbf{nullptr} (è un \emph{pointer literal}), specifico del C++ è sempre un puntatore, di tipo \emph{std::nullptr\_t} (è un prvalue di tipo nullptr\_t), un puntatore a tutti gli effetti. Se lo si cerca di adottare ad un'altra variabile, tipo ad un int darà errore.} \\

\textsf{\small \textbf{nullptr} è implicitamente convertibile a qualsiasi tipo di puntatore.} \\

\begin{lstlisting}
	// Esempio 1
	#include <iostream>
	
	int main()
	{
		int ptr = nullptr; // Errore.
		
		int *ptr = nullptr; // Va bene.
		return 0;
	}
\end{lstlisting}

\begin{lstlisting}
	// Esempio 2
	#include <iostream>
	
	void func(int n);
	void func(char *s);
	
	func ( NULL ); // Quale delle due funzioni verrà chiamata? La prima, perché NULL è 0 e quindi un int.
\end{lstlisting}

\textsf{\small \textbf{nullptr} è definito nell'header \textbf{<cstddef>}, ma non serve includerlo perché è una \emph{built-in} keyword.} \\ 

% -------------------------- SECTION: STRINGHE ---------------------------------------

\newpage

\section{Stringhe}

%TODO: mettere std::string qui? E anche char? e c-strings? anche la Tabella ASCII?
%Prima questa parte dei char, C-string, std::string stava nella sezione Tipi di Dati

\subsection{Char}

\textsf{\small \textbf{Definizione: } Un \textbf{char} è usato per memorizzare un singolo carattere} \\

\textsf{\small Alternativamente, si possono usare i valori ASCII per indentificare le lettere} \\

\begin{lstlisting}
	char linguaggio = 'C';
	
	char linguaggio = 67; // 67 corrisponde a C nella tabella ASCII.
\end{lstlisting}

\subsection{C-string}

\textsf{\small Per creare una stringa in C facciamo un array (contenitore di dati dello stesso tipo) di char.}

\textsf{\small Il \textbf{'\textbackslash0'} è il \textbf{NUL terminator} che denota la fine di una C-stringa. } \\

\begin{lstlisting}
	char s[] = "prova";
	
	// Oppure possiamo scriverlo:
	char s[] = { 'p', 'r', 'o', 'v', 'a', '\0'};
	
	// '\textbackslash0' è il NUL terminator, denota la fine di una stringa.
\end{lstlisting}

\subsection{char*}

\textsf{\small Un puntatore a char memorizza la locazione iniziale di una C-string (una stringa in C). } \\

\begin{lstlisting}
	char s = "prova";
	
	// Possiamo far puntatore al puntatore la prima cella dell'array così..
	char* p = &(s[0]);
	
	// ..oppure in maniera più coincisa così:
	char *p = s;
\end{lstlisting}

\subsection{Tabella ASCII}

\textsf{\small \textbf{Definizione: } La tabella \textbf{ASCII} (\emph{American Standard Code for Information Interchange}) è un codice per la codifica di caratteri.} \\

\textsf{\small Inizialmente era basata su codici di 7 bit, quindi per un totale di $2^7 = 128$ caratteri. Venne poi estesa ad 8 bit, per un totale di $2^8 = 256$ caratteri.} \\

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/ascii_table2.png}
	\caption{Tabella ASCII}
	\label{fig:ascii_table}
\end{figure}

\subsection{std::string}

\textsf{\small \textbf{Definizione: } Il C++ ha una propria definizione per rappresentare una sequenza di caratteri come un oggetto di una classe. Questa classe è chiamata std::string. Questa memorizza i caratteri come una sequenza di bytes con la funzionalità di poter accedere al singolo carattere byte.} \\

\textsf{\small La classe std::string ha diverse funzioni, come: } 

\begin{tabular}{|c|c|}
	\hline
	\textbf{Funzione} & \textbf{Definizione} \\
	\hline
	\textbf{length()} & \textsf{\small restituisce la lunghezza della stringa.} \\
	\hline
	\textbf{capacity()} & \textsf{\small restituisce la capacità allocata alla stringa che } \\
	\textbf{} & \textsf{\small può essere più o meno la lunghezza.} \\
	\hline
	\textbf{resize()} & \textsf{\small cambia la grandezza della stringa che può essere } \\
	\textbf{} & \textsf{\small aumentata o diminuita.} \\
	\hline
	\textbf{shrink\_to\_fit()} & \textsf{\small diminuisce la grandezza della stringa e la rende uguale } \\
	\textbf{} & \textsf{\small al minimo della capacità della stringa.} \\
	\textbf{} & \textsf{\small Utile per salvare ulteriore memoria se siamo sicuri } \\
	\textbf{} & \textsf{\small di non dover aggiungere altri caratteri.} \\
	\hline
	%\textbf{} & \textsf{\small } \\
\end{tabular} 

\textsf{\small Queste sono solo alcune delle funzioni della classe string.} \\

\begin{lstlisting}
	#include <iostream>
	
	std::string str = "Ciao a tutti";
	
	str.resize(4); 
	
	std::cout << "Stringa dopo resize: " << str << std::endl; // Output : Stringa dopo resize: Ciao
	
	std::cout << "Capacità della stringa: " << str.capacity() << std::endl; // Output : Capacità della stringa: 12
	
	std::cout << "Lunghezza della stringa: " << str.length() << std::endl; // Output : Lunghezza della stringa: 4
	
\end{lstlisting}

\subsection{char* vs std::string vs char[]}

\subsubsection{Usare char*}

\begin{lstlisting}
	char *str = "prova";
\end{lstlisting}

\begin{tabular}{|c|c|} 
	\hline
	\color{red} CONS & \color{Green} PROS \\
	\hline
	\textsf{\small In C va bene, ma in C++ è deprecato,  } & \textsf{\small Basta un singolo puntatore per  } \\
	\textsf{\small perché in C le stringhe sono array di char,} & \textsf{\small l'intera stringa. È efficiente } \\
	\textsf{\small mentre in C++ sono array di char costanti.} & \textsf{\small a livello di memoria.} \\
	\hline
	\textsf{\small Non possiamo modificare la stringa dopo, } & \textsf{\small Non c'è bisogno  } \\
	\textsf{\small possiamo semplicemente } & \textsf{\small di dichiarare la lunghezza } \\
	\textsf{\small far puntare ad un'altra stringa.} & \textsf{\small della stringa all' inizializzazione.} \\
	\hline
\end{tabular}

\subsubsection{Usare std::string}

\begin{lstlisting}
	std::string s = "prova";
\end{lstlisting}

\begin{tabular}{|c|c|}
	\hline
	\color{red} CONS & \color{Green} PROS \\
	\hline
	\textsf{\small } & \textsf{\small Con C++ std::string è la migliore via,  } \\
	\textsf{\small } & \textsf{\small perché ha delle funzioni di ricerca,} \\
	\textsf{\small } & \textsf{\small rimpiazzo e manipolazione migliori.} \\
	%\textsf{\small } & \textsf{\small } \\
	\hline
\end{tabular}

\subsubsection{Casi in cui preferire char* ad std::string}

\begin{itemize}
	\item \textsf{\small Quando si ha a che fare con livelli bassi di accesso, come interagire con il sitema operativo. Anche se std::string::c\_str dovrebbe occuparsi di quello.}
	\item \textsf{\small Compatibilità con del vecchio codice in C (anche se la funzione std::string::c\_str dovrebbe già in largo modo occuparsi di questo).}
	\item \textsf{\small Per risparmiare memoria (std::string sicuramente occupa di più).}
\end{itemize}

\subsubsection{Usare char[]}

\begin{lstlisting}
	// In realtà ci bastano 5 spazi nell'array, però se poi dopo vogliamo fare
	// concatenazioni o manipolazioni sulle altre stringhe, ci servirà altro spazio.
	char stringa[128] = "prova";
\end{lstlisting}

\begin{tabular}{|c|c|}
	\hline
	\color{red} CONS & \color{Green} PROS \\
	\hline
	\textsf{\small È un array allocato  } & \textsf{\small Possiamo modificare la stringa } \\
	\textsf{\small staticamente che consuma } & \textsf{\small anche in un } \\
	\textsf{\small spazio nello stack.} & \textsf{\small altro stage del programma.} \\
	\hline
	\textsf{\small Dobbiamo utilizzare array di grandi dimensioni  } & \textsf{\small } \\
	\textsf{\small per poter concatenare } & \textsf{\small } \\
	\textsf{\small o manipolare le altre stringhe,} & \textsf{\small } \\
	\textsf{\small visto che lo spazio dell'array } & \textsf{\small } \\
	\textsf{\small è fissato dall'inizio.} & \textsf{\small } \\
	\hline
\end{tabular}

\subsection{Escape characters}

\textsf{\small \textbf{Definizione: } Le sequenze di fuga sono usate per rappresentare certi caratteri speciali nelle stringhe e nei caratteri. } \\

\textbf{Caratteri di controllo: } \\

\textsf{\small Compatibili con l'encoding ASCII.} \\

%TODO: magari da tradurre in italiano il resto e o lasciare qui o all'inizio dopo il cast.

\begin{tabular}{|c|c|}
	\hline
	\textbf{Escape sequence} & \textbf{Definizione} \\
	\hline
	\textsf{\small \textbf{$\backslash$a} : \textbf{$\backslash$x07}} & \textsf{\small alert (bell)} \\
	\hline
	\textsf{\small \textbf{$\backslash$b} : \textbf{$\backslash$x08}} & \textsf{\small backspace} \\
	\hline
	\textsf{\small \textbf{$\backslash$t} : \textbf{$\backslash$x09}} & \textsf{\small horizontal tab} \\
	\hline
	\textsf{\small \textbf{$\backslash$n} : \textbf{$\backslash$x0A}} & \textsf{\small newline (or line feed)} \\
	\hline
	\textsf{\small \textbf{$\backslash$v} : \textbf{$\backslash$x0B}} & \textsf{\small vertical tab} \\
	\hline
	\textsf{\small \textbf{$\backslash$f} : \textbf{$\backslash$x0C}} & \textsf{\small form feed} \\
	\hline
	\textsf{\small \textbf{$\backslash$r} : \textbf{$\backslash$x0D}} & \textsf{\small carriage return} \\
	\hline
	\textsf{\small \textbf{$\backslash$e} : \textbf{$\backslash$x1B}} & \textsf{\small escape (non-standard GCC extension)} \\
	\hline
\end{tabular} \break

\textbf{Caratteri di punteggiatura: } \\

\begin{tabular}{|c|c|}
	\hline
	\textbf{Escape sequence} & \textbf{Definizione} \\
	\hline
	\textsf{\small \textbf{$\backslash$"}} & \textsf{\small quotation mark} \\
	\hline
	\textsf{\small \textbf{$\backslash$'}} & \textsf{\small apostrophe} \\
	\hline
	\textsf{\small \textbf{$\backslash$?}} & \textsf{\small question mark (used to avoid trigraphs)} \\
	\hline
	\textsf{\small \textbf{$\backslash\backslash$}} & \textsf{\small backslash} \\
	\hline
\end{tabular} \break

\textbf{Caratteri di referenze numeriche: } \\

\begin{tabular}{|c|c|}
	\hline
	\textbf{Escape sequence} & \textbf{Definizione} \\
	\hline
	\textsf{\small \textbf{$\backslash$}} & \textsf{\small + 3 cifre in ottale} \\
	\hline
	\textsf{\small \textbf{$\backslash$x}} & \textsf{\small + qualsiasi cifra in esadecimale} \\
	\hline
	\textsf{\small \textbf{$\backslash$u}} & \textsf{\small + 4 cifre esadecimali} \\
	\hline
	\textsf{\small \textbf{$\backslash$U}} & \textsf{\small + 8 cifre esadecimali} \\
	\hline
	\textsf{\small \textbf{$\backslash$0} = \textbf{$\backslash$00} = $\backslash$000} & \textsf{\small octal escape for null character} \\
	\hline
\end{tabular}

\subsubsection{'$\backslash$n' vs "$\backslash$n"}

\textsf{\small \textbf{'$\backslash$n'} è un carattere.} \\

\textsf{\small \textbf{"$\backslash$n"} è un puntatore ad un array di caratteri (una stringa), ovvero l'equivalente di \{ '$\backslash$n', '$\backslash$0' \} ($\backslash$n più il terminatore nullo).} \\

\textsf{\small Quale è meglio utilizzare dipende dalla situazione: in una std::string per esempio un \textbf{char} non si può inserire (quindi '$\backslash$n' non funzionerebbe), ma un \textbf{const char*} si. \label{newline_apici_o_virgolette}} \\

% -------------------------- SECTION: FUNZIONI ---------------------------------------

\newpage

\section{Funzioni}

\textsf{\small \textbf{Definizione: } Una funzione è un blocco di codice che esegue una specifico compito e può essere richiamato quando si vuole.} \\

\textsf{\small Le funzioni sono composte da: un tipo di dato di ritorno che è ciò che la funzione restituisce dopo esser stata eseguita, un nome, degli eventuali parametri e racchiuso tra due parentesi graffe c'è il corpo, il blocco di codice.}

\textsf{\small Per eseguire la funzione basta richiamarla col suo nome e passare gli eventuali parametri.} \\

\subsection{return}

\textsf{\small La keyword \textbf{return} permette di restituire un valore/oggetto dalla funzione.} \\

\begin{lstlisting}
	// tipologia nome\_funzione(parametri)
	{
		// Blocco di codice della funzione.
	}
	
	// Questa funzione restituisce un intero, si chiama somma, prende due parametri interi a e b e restituisce la somma tra a e b. 
	int somma(int a, int b){
		return a + b;
	}
	
	// Fuori dalla funzione
	int x = 3, y = 5;
	// chiamiamo la funzione somma, gli passiamo i parametri e il valore di ritorno e lo assegniamo alla variabile intera z.
	int z = somma(x, y); // Output z : 8
\end{lstlisting}

\textsf{\small Tutto ciò che è creato all'interno della funzione è locale alla funzione e quindi non accessibile da fuori.} \\

\textsf{\small I nomi dei parametri sono soltanto dei placeholders. Potremmo anche non metterli e lasciare solo le tipologie, ma poi per poterli referenziare nella funzione non sapremmo come fare.}

\textsf{\small I parametri che vengono passati alla funzione sono anch'essi locali, a meno che non li si passano attraverso dei puntatori.} \\

\textsf{\small I parametri passati, a meno che con puntatori, sono delle copie delle variabili passate come parametro, e qualsiasi modifiche di queste copie non ha alcun effetto sui parametri passati.} \\

\begin{lstlisting}
	// Questa è una funzione che restituisce un boolean (0 o 1 (VERO o FALSO)), chiamata isGreater che prende due variabili intere a e b come parametri e restituisce true se la variabile a è maggiore della variabile b, altrimenti false.
	
	// Questa funzione si potrebbe scrivere così..
	bool isGreater(int a, int b)
	{
		if(a > b){
			return a;
		} else {
			return b;
		}
	}

	//.. Oppure si potrebbe anche scrivere così.
	bool isGreater(int a, int b)
	{
		return a > b;
	}

	// Detto questo, per questo tipo di operazioni, ci sono già delle funzioni della libreria Standard ben più ottimizzate. Per questo esempio si potrebbe usare std::max.
\end{lstlisting}

\subsection{void}

\textsf{\small Se non volessimo ritornare niente dovremmo usare la tipologia \textbf{void}, questo tipo di funzione (che non ritorna niente) è chiamata \textbf{procedura}.} \\

\subsection{main}

\textsf{\small Il \textbf{main} è la funzione principale di qualsiasi programma in C/C++, da esso parte il tutto, ha origine tutto.} \\

\begin{lstlisting}
	int main(){
		return 0;
	}
\end{lstlisting}

\textsf{\small Tutti i programmi in C++ devono avere un \textbf{main}, senza non funzionano.} \\

\textsf{\small Senza il \textbf{main} un errore verrebbe lanciato dal compilatore: \emph{undefined reference to `main`}.} \\

\textsf{\small Se modificassimo il nome del main verrebbe lanciato anche in questo caso un errore perché il main non esisterebbe.} \\

\textsf{\small Il \textbf{main} viene invocato automaticamente quando il programma viene eseguito; è il punto di origine di ogni programma.} \\

\subsection{Funzioni ricorsive}

\textsf{\small Le funzioni ricorsive sono delle funzioni che richiamano se stesse per raggiungere un risultato.} \\

\begin{lstlisting}
	#include <iostream>
	
	// Il fattoriale di un numero, o anche scritto n! è n * (n - 1)
	// 4! = 4 * 3 * 2 * 1 = 24
	int fattoriale(int n)
	{
		if((n == 0) || (n == 1))
			return 1;
		else
			return n * fattoriale(n - 1);
	}

	// Questa funzione si potrebbe anche scrivere
	int fattoriale(int n)
	{
		// Le parentesi nella condizione non servirebbero, le lascio per chiarezza
		return ((n == 0) || (n == 1)) ? 1 : n * fattoriale(n - 1);
	}

	// Fibonacci è una serie in cui i due primi elementi sono 1 e dove ogni elemento è uguale alla somma dei due termini precedenti. 
	
	int fibonacci(int x)
	{
		// Le parentesi nella condizione non servirebbero, le lascio per chiarezza
		return ((x == 1) || (x == 0)) ? x : fibonacci(x - 1) + fibonacci(x - 2);
	}

	int main()
	{
		int x = 4;
		std::cout << "Fattoriale di " << x << " e\': " << fattoriale(x) << std::endl; // Output : Fattoriale di 4 è 24.
		
		int y = 15;
		std::cout << "Fibonacci di " << y << " e\' " << fibonacci(15) << std::endl; // Output : Fibonacci di 15 è 610.
		return 0;
	}
\end{lstlisting}

\subsection{Argomenti passati per valore}

\textsf{\small Quindi, quando passiamo dei valori (e non degli indirizzi di memoria alle variabili), si dice che passiamo gli argomenti \textbf{per valore}, quindi una copia delle variabili passate viene creata ed usata nelle funzioni. }

\textsf{\small Quindi noi non operiamo direttamente sulle variabili passate, ma sulle loro copie. Questo non ci permette di poter modificare le variabili passate.} \\

\begin{lstlisting}
	int sottrazione(int a, int b)
	{
		return a - b;
	}

	// Fuori dalla funzione
	int x = 5, y = 3;
	int z = sottrazione(x, y); // Output: 2
\end{lstlisting}

\subsection{Argomenti passati per referenza}

\textsf{\small Per poter effettivamente modificare le variabili che abbiamo passato per argomento, dobbiamo passarle con i puntatori, dobbiamo passare i loro indirizzi di memoria. Questo si chiama passare argomenti \textbf{per referenza}.} \\

\textsf{\small Se, per esempio, volessimo sostituire i valori di due variabili e li passassimo per valore, non riusciremmo.} \\

\begin{lstlisting}
	#include <iostream>
	
	// Parte 1: Usare argomenti passati per valore.
	void swap(int a, int b)
	{
		int temp = a;
		a = b;
		b = temp;
	}

	// Fuori dalla funzione
	int x = 5, y = 3;
	swap(x, y); 
	std::cout << "Valore di x dopo lo swap: " << x << std::endl; // Output : 5
	std::cout << "Valore di y dopo lo swap: " << y << std::endl; // Output : 3
	// Non funziona, noi vorremmo cambiare i valori di x ed y, ma così non funziona, perchè stiamo lavorando sulle copie delle variabili, non sulle variabili stesse.
	
	// Parte 2: Usare argomneti passati per referenza
	void swap(int *a, int *b)
	{
		int temp = *a;
		*a = *b;
		*b = temp;
	}

	// Fuori dalla funzione
	int x = 5, y = 3;
	swap(x, y);
	std::cout << "Valore di x dopo lo swap: " << x << std::endl; // Output : 3
	std::cout << "Valore di y dopo lo swap: " << y << std::endl; // Output : 5
	
	// Ha funzionato, perché abbiamo agito sulle variabili passate e non sulle loro copie.
	
	// Quello visto prima ero un modo per poter fare la funzione swap in C che funziona anche in C++, ma c'è anche un altro modo ovvero utilizzando le references.
	
	void swap(int &a, int &b)
	{
		int temp = a;
		a = b;
		b = temp;
	}

	// Fuori dalla funzione
	int x = 5, y = 3;
	swap(x, y);
	std::cout << "Valore di x dopo lo swap: " << x << std::endl; // Output : 3
	std::cout << "Valore di y dopo lo swap: " << y << std::endl; // Output : 5
	
	// Comunque c'è una funzione della libreria Standard std::swap() per questo.
\end{lstlisting}

\subsection{Funzioni che ritornano puntatori}

\textsf{\small Si possono, naturalmente, ritornare i puntatori dalle funzioni.}

\begin{lstlisting}
	#include <iostream>
	
	int* func()
	{
		static int a = 11; // static così rimane sempre in memoria anche quando non si chiama la funzione
		return &a;
	}

	int *p;
	
	p = func();
	
	std::cout << p << std::endl; // Output : indirizzo di p
	std::cout << *p << std::endl; // Output : 11
\end{lstlisting}

%TODO: magari scrivere a cosa possa essere utile ritornare i puntatori dalle funzioni.

\subsection{Parametri di default}

\textsf{\small Nel caso un programmatore non passi un argomento, possiamo impostare un \textbf{argomento di default} così che se non viene passato, viene utilizzato l'\textbf{argomento di default}. } \\

\textsf{\small Per settarli bisogna porre l'\textbf{=} e poi il valore di default dopo il nome dell'argomento.} \\

\begin{lstlisting}
	#include <iostream>
	
	int somma(int a, int b)
	{
		return a + b;
	}

	// l'argomento b ha un valore di default di 0 (avremmo potuto mettere qualsiasi altro valore).
	int somma2(int a, int b = 0) 
	{
		return a + b;
	}

	int somma3(int a = 2, int b = 7)
	{
		return a + b;
	}

	int somma4(int a = 6, int b)
	{
		return a + b;
	}

	int main()
	{
		std::cout << somma(5) << std::endl; //Output: Errore perché è stato passato solo un parametro su due.
		
		std::cout << somma2(5) << std::endl; //Output: 5 (perché il secondo parametro è di default 0)
		
		std::cout << somma2(5, 3) << std::endl; //Output: 8 (perché in questo caso abbiamo passato un secondo parametro e quindi viene utilizzato quello al posto del parametro di default)
		
		std::cout << somma3() << std::endl; //Output: 9 (perché abbiamo impostato dei valori di default di 2 e 7)
		
		std::cout << somma4(, 10) << std::endl; //Output: Errore questo non è possibile! e neppure somma4(10);
		return 0;
	}
\end{lstlisting}

\textsf{\small Nel capitolo \emph{Le gemme degli Algoritmi} a pag.\textbf{\pageref{optionals}} useremo gli \textbf{std::optional} che ci aiuteranno con i parametri di default.} \\

\subsection{Funzione constexpr}

\textsf{\small Porre \textbf{constexpr} in una funzione significa: che quella funzione può essere valutata a tempo di compilazione e l'espressione può essere usata in altre espressioni costanti. } \\

\begin{lstlisting}
	#include <iostream>
	
	constexpr int product(int x, int y)
	{
		return x * y;
	}

	int main()
	{
		const int x = product(5, 4);
		
		std::cout << x << std::endl; //Output: 20
		return 0;
	}
\end{lstlisting}

\begin{itemize}
	\item \textsf{\small Nel C++11 una funzione constexpr non può avere più di un \textbf{return} a differenza del C++14 e avanti.}
	\item \textsf{\small Queste funzioni dovrebbero riferire solo a variabili globali costanti.}
	\item \textsf{\small Queste funzioni possono soltanto chiamare altre \textbf{funzioni constexpr}, non le normali funzioni.}
	\item \textsf{\small Queste funzioni non dovrebbero essere di tipo \textbf{void}.}
	\item \textsf{\small Alcuni operatori come l'incremento prefisso (++i) non sono permessi nel C++11, ma dal C++14 in avanti sì.}
\end{itemize}

% -------------------------- SECTION: VARIABLES SCOPE --------------------------------

\section{Variables Scope}

\textsf{\small Variables Scopes, o in italiano, la portata delle variabili, significa fino a dove una variabile può essere utilizzata, fino a dove esiste, vale, la possiamo usare.} \\

\textsf{\small La portata è una regione del programma; ci sono all'incirca 3 principali posti in cui le variabili possono essere dichiarate ed in base a questo le variabili assumono diversi nomi: }

\begin{itemize}
	\item \textsf{\small \textbf{Locali} : dentro ad una funzione o ad un blocco di codice (racchiuso tra le graffe).}
	\item \textsf{\small \textbf{Parametri formali} : ovvero nella definizione della funzione, nei suoi parametri.}
	\item \textsf{\small \textbf{Globale} : fuori dalle funzioni.}
\end{itemize}

\subsection{Variabili Locali}

\textsf{\small Le variabili create all'interno di una funzione o un blocco di codice, sono locali a quella funzione, possono essere utilizzate solo all'interno di quella funzione e non all'esterno. Una volta che la funzione termina, quella variabile cessa di esistere.} \\

\begin{lstlisting}
	#include <iostream>
	
	void funzione()
	{
		int a = 5;
		std::cout << "Valore variabile locale a: " << a << std::endl;
	}
	
	// Fuori dalla funzione
	funzione(); // Output : Valore variabile locale a: 5
	
	std::cout << "Valore variabile locale a: " << a << std::endl; // Errore la variabile a non esiste!
\end{lstlisting}

\subsection{Parametri formali}

\textsf{\small Sono i parametri della funzione, esistono soltanto finchè la funzione esiste.} \\

\begin{lstlisting}
	#include <iostream>
	
	void funzione(int a)
	{
		std::cout << "Valore variabile a: " << a << std::endl;
	}
	
	int main()
	{
		int x = 8;
		funzione(x); // Output Valore variabile a: 8
		
		std::cout << "Valore variabile a: " << a << std::endl; // Errore non esiste in questo scope.
		
		return 0;
	}
\end{lstlisting}

\subsection{Variabili Globali}

\textsf{\small Esistono per tutta la durata del programma, posso essere utilizzate anche all'interno delle funzioni e il loro valore non viene perso una volta che la funzione smette.} \\

\begin{lstlisting}
	#include <iostream>
	
	int x = 10;
	
	void funzione()
	{
		std::cout << "Valore variabile x: " << x << std::endl;
	}
	
	int main()
	{
		funzione(); // Output Valore variabile x: 10
		return 0;
	}
\end{lstlisting}

\subsubsection{Perché evitare le variabili globali}

\textsf{\small In generale, sarebbe meglio evitare di usare variabili globali perché: } \\

\begin{itemize}
	\item \textsf{\small Tutte le funzioni hanno accesso alle variabili globali, il che renderebbe difficile, nel lungo andare, capire chi scrive e legge queste variabili.}
	\item \textsf{\small Non c'è un controllo su chi può accedervi.}
	\item \textsf{\small Peggiorano la chiarezza del codice.}
	%\item \textsf{\small }
\end{itemize}

% -------------------------- SECTION: HEADERS ----------------------------------------

\newpage

\section{Header files}

\textsf{\small \textbf{Definizione: } Gli header files, o file di intestazione in italiano, sono dei files con l'estensione \textbf{.h} o \textbf{.hpp} che contengono le dichiarazioni delle funzioni e definizioni di macro e tipi.}\\

\textsf{\small Sono un modo per organizzare il codice; possiamo includere gli elementi di questi files nel nostro codice attraverso la direttiva \textbf{\#include} che informa il preprocessore di cercare questo file prima di continuare ad eseguire il codice. } 

\textsf{\small Esistono due tipi di header files: quelli standard del linguaggio/compilatore e quelli creati dall'utente programmatore.}

\textsf{\small Per includere le librerie standard usiamo \textbf{\#include <nomelibreria>} perché il compilatore sa dove si trovano queste librerie, mentre per le librerie definite dall'utente usiamo \textbf{\#include "nomelibreria.h"} e passiamo anche il percorso di dove si trova. (a meno che non si trova nella stessa cartella in cui si trova il nostro codice, in quel caso basta mettere il nome della libreria)} \\

% \texorpdfstring % per inserire caratteri speciali nelle section, subsection, ecc.
\subsection{Only Once Headers | pragma once | ifndef}

\textsf{\small \textbf{Definizione: } Se un file header viene incluso due volte, il compilatore processerà il suo contenuto due volte, il che risulterà in un errore. Per evitare questo c'è una procedura standard da scrivere all'interno del file di intestazione.}

\begin{lstlisting}
	#ifndef NOME_HEADER_FILE_H
	#define NOME_HEADER_FILE_H
	
	// Tra queste c'è il codice dell'header file.
	
	#endif
\end{lstlisting}

\textsf{\small La direttiva \textbf{\#ifndef} controlla che il file non sia già stato aggiunto, se così fosse, allora lo aggiunge, altrimenti salta il suo contenuto così che non verrà aggiunto due volte.} \\

\textsf{\small Inoltre, per fare questa stessa operazione, ma più semplice e corta esiste una direttiva non-standard: \textbf{\#pragma once}. } 

\begin{lstlisting}
	#pragma once
	
	// Contenuto dell'header.
\end{lstlisting}

\subsection{Cosa sono le librerie?}

\textsf{\small Le librerie sono collezioni di risorse non volatili usate dai programmi. La libreria Standard è una collezione di classi, funzioni, macros, costanti, ecc. che sono state scritte in C++ stesso. Ci sono una grande lista di header files che contengono i contenuti della libreria Standard.} \\

\subsection{Header files libreria Standard}

\textsf{\small Qui, una lista degli header files della libreria standard più comuni (alcuni anche del C): } \break

\begin{tabular}{cc}
	\textbf{\#include <stdio.h>} : & \textsf{\small per l'input ed output (dal C).} \\
	\textbf{\#include <iostream>} : & \textsf{\small input ed output fondamentali.} \\
	\textbf{\#include <string>} : & \textsf{\small fornisce le classi standard string e template.} \\
	\textbf{\#include <math.h>} : & \textsf{\small per operazioni matematiche (dal C).} \\
	\textbf{\#include <limits>} : & \textsf{\small usata per descrivere proprietà di } \\
	\textbf{} & \textsf{tipi numerici fondamentali.} \\
	\textbf{\#include <time.h>} : & \textsf{\small per funzioni legate al tempo (dal C).} \\
	\textbf{\#include <chrono>} : & \textsf{\small fornisce elementi di tempo, come std::chrono::duration } \\
	\textbf{} & \textsf{\small e std::chrono::time\_point ed altri.} \\
	\textbf{\#include <algorithm>} : & \textsf{\small fornisce la definzione di molti container algoritmici.} \\
	\textbf{\#include <iterator>} : & \textsf{\small fornisce templates e classi } \\
	\textbf{} & \textsf{per lavorare con gli iteratori.} \\
	\textbf{\#include <sstream>} : & \textsf{\small fornisce delle classi per la } \\
	\textbf{} & \textsf{manipolazione di stringhe stream.} \\
	\textbf{\#include <vector>} : & \textsf{\small fornisce la classe di template container std::vector, } \\
	\textbf{} & \textsf{\small un array dinamico.} \\
	\textbf{\#include <random>} : & \textsf{\small facilita la generazione di numeri (pseudo-)casuali } \\
	\textbf{} & \textsf{\small e distribuzioni.} \\
	\textbf{\#include <numeric>} : & \textsf{\small operazioni numeriche generalizzate.} \\
	\textbf{\#include <functional>} : & \textsf{\small fornisce diversi oggetti funzionali da usare } \\
	\textbf{} & \textsf{\small con gli standard algorithm.} \\
	\textbf{\#include <stdexcept>} : & \textsf{\small classi per le eccezioni.} \\
	\textbf{\#include <memory>} : & \textsf{\small per la gestione della memoria.} \\
	\textbf{\#include <optional>} : & \textsf{\small per gli opzionali.} \\
	\textbf{\#include <ranges>} : & \textsf{\small per i ranges e per i lazy evaluated adaptors. (C++20)} \\
	%\textbf{} & \textsf{} \\
	\textbf{\#include <concepts>} : & \textsf{\small fornisce la libreria fondamentale concepts. (C++20)} \\
	%\textbf{} & \textsf{} \\
	\textbf{\#include <thread>} : & \textsf{\small fornisce classi e namespaces } \\
	\textbf{} & \textsf{per lavorare sui threads.} \\
\end{tabular} \break

\textsf{\small Inoltre, tutti gli headers dalla libreria standard del C sono inclusi nella libreria standard del C++}

\textsf{\small Ci sono tanti altri headers file e ognuno usato per qualcosa..} \\

\subsection{Librerie create dagli utenti}

\textsf{\small Gli utenti possono comporre le proprie librerie, creando un file \textbf{.h} con le sole definizioni di funzioni e un file chiamato come l'header file, con le implementazioni di queste, ma con l'estensione \textbf{.cpp}.}

\textsf{\small Per includere queste librerie, usiamo \textbf{\#include "nome\_libreria.h"}, al posto di \textbf{\#include <nomelibreria.h>}, perché non è una libreria standard e quindi il compilatore non sa dove cercarla e quindi gli dobbiamo specificare noi dove si trova la nostra libreria.} \\

\begin{lstlisting}
	// Nel file header nomelibreria.h
	int somma(int a, int b);
	
	// Nel file .cpp nomelibreria.cpp
	#include "nomelibreria.h"
	
	int somma(int a, int b){
		return a + b;
	}
\end{lstlisting}

\subsection{Differenza tra .h vs .hpp}

\textsf{\small In C++ l'estensione del file non è importante. L'uso di .h , .hpp, .hxx, .hh, .tpp o nessuna estensione sono tutte convenzioni.} \\

\begin{tabular}{|c|c|}
	\hline
	\textbf{.h} & \textbf{.hpp} \\
	\hline
	\textsf{\small Sia per il C che per il C++} & \textsf{\small È solo per C++} \\
	\textsf{\small Dal punto di vista del C++, } & \textsf{\small Non funzionerà con il C.} \\
	\textsf{\small il codice C verrà definito come \emph{extern "C"}} & \textsf{\small } \\
	\textsf{\small Esprime l'intento che si usa il C } & \textsf{\small Esprime l'intento che } \\
	\textsf{\small (o perlomeno si può pensare così)} & \textsf{\small si usa il C++ } \\
	\textsf{\small Dal punto di vista del C, il codice C sarà visibile, } & \textsf{\small (o perlomeno si può pensare così)} \\
	\textsf{\small mentre quello del C++ sarà invisibile.} & \textsf{\small } \\
	\hline
\end{tabular}

%TODO: cosa sono le librerie? Questi sono solo file di intestazioni.

% -------------------------- SECTION: NAMESPACES -------------------------------------

\newpage

\section{Namespaces}

\textsf{\small \textbf{Definizione: } I \textbf{namespaces} ci permettono di raggruppare varie entità che altrimenti si troverebbero nello scope globale. Permettono una migliore organizzazione e strutturazione del codice.} \\

\textsf{\small Se avessimo per esempio due funzioni con lo stesso nome, sarebbe difficile differenziarle e quindi i namespaces ci permettono di separarle.}

\textsf{\small Per creare una namespace adoperiamo la keyword \textbf{namespace}.} \\

\begin{lstlisting}
	#include <iostream>
	
	namespace primo_spazio {
		void func()
		{
			std::cout << "Dentro al namespace: primo_spazio" << std::endl;
		}
	}

	namespace secondo_spazio {
		void func()
		{
			std::cout << "Dentro al namespace: secondo_spazio" << std::endl;
		}
	}

	int main()
	{
		// Chiamo la funzione func del primo spazio.
		primo_spazio::func();
		// Output: Dentro al namespace: primo\_spazio
		
		// Chiamo la funzione func del secondo spazio.
		secondo_spazio::func();
		// Output: Dentro al namespace: secondo\_spazio
		return 0;
	}
\end{lstlisting}

\textsf{\small Il namespace più usato è quello della libreria Standard del linguaggio, ovvero il namespace \textbf{std} che raggruppa tutte le funzioni e classi della libreria Standard. } \\

\textsf{\small Ogni qualvolta che usiamo una funzione, classe della libreria Standard ci riferiamo a quel namespace. Usiamo il nome del namespace e i due punti :: per indicare che quello che stiamo usando fa parte di quel namespace. C'è un modo, però per evitare ogni volta di scrivere std::, ed è attraverso la riga \textbf{using namespace std;}. Con questo non abbiamo più bisogno di scrivere std::, perché lo da già per scontato, o meglio, li prende direttamente dalla libreria Standard.} \\

\begin{lstlisting}
	// Accediamo al namespace std.
	std::string s = "Hello World!";
	
	// Qui invece facciamo la stessa cosa, ma senza dover riscrivere ogni volta std::
	using namespace std;
	
	string s = "Hello World!";
\end{lstlisting}


\subsection{std:: vs using namespace std}

\textsf{\small Usare \textbf{using namespace std} è considerato una \textbf{\color{red}bad practice}, probabilmente ci sono diversi motivi per questo, ma qui ne elenco alcuni: } \\

\begin{itemize}
	\item \textsf{\small Come abbiamo detto prima, se noi per esempio abbiamo due namespaces con due funzioni con lo stesso nome, se noi usiamo \emph{using namespace nome\_del\_namespace} allora avremmo un conflitto, o meglio, avremmo due namespaces con una funzione con lo stesso nome, il che creerebbe confusione. (e questo non vale solo per le funzioni, ma anche per le classi, costanti, ecc.). Il programma ancora compilerebbe, ma potrebbe chiamare la funzione sbagliata.}
	\item \textsf{\small Usare \emph{using namespace std} importerebbe nel nostro programma l'intero namespace std anche quando a noi serve solo una parte del namespace. \textbf{Non} è un problema di performance, ma solo di chiarezza del codice e di evitare ambiguità.}
	\item \textsf{\small Scrivere invece \textbf{std::} ogni volta rende chiaro il codice, perchè si capisce subito da quale namespace stai prendendo quella data funzione e/o altro.}
	%\item \textsf{\small }
\end{itemize}

\textsf{\small Quindi, per rendere il codice più chiaro è meglio usare \textbf{std::} al posto del using namespace std;} \\

\begin{lstlisting}
	#include <iostream>
	
	// Se rimostrassimo il codice di prima
	
	namespace primo_spazio {
		void func()
		{
			std::cout << "Dentro al namespace: primo_spazio" << std::endl;
		}
	}
	
	namespace secondo_spazio {
		void func()
		{
			std::cout << "Dentro al namespace: secondo_spazio" << std::endl;
		}
	}

	using namespace primo_spazio;
	using namespace secondo_spazio;
	
	int main()
	{
		// Il codice diventa ambiguo!
		func();
		func();
		return 0;
	}
\end{lstlisting}

\textsf{\small Un modo per evitare questa ambiguità sarebbe usando la keyword \textbf{typedef} che permette essenzialmente di rinominare una keyword.}

\begin{lstlisting}
	// Questo eviterebbe in parte l'ambiguità, ma comunque rimane meglio mettere nome\_del\_namespace::funzione.
	typedef primo_spazio::func() primo_func();
	typedef secondo_spazio::func() secondo_func();
	
	int main()
	{
		// Chiamo la funzione func del primo spazio.
		primo_func();
		// Output: Dentro al namespace: primo\_spazio
		
		// Chiamo la funzione func del secondo spazio.
		secondo_func();
		// Output: Dentro al namespace: secondo\_spazio
		return 0;
	}
\end{lstlisting}

\textsf{\small Al posto di importare l'intero namespace std, si potrebbe troncare e portare solo una parte del namespace std.} \\

\begin{lstlisting}
	using std::cout;
	
	std::string s = "Hello World!"
	
	cout << s << std::endl;
\end{lstlisting}

\textsf{\small Comunque, in generale è meglio usare \textbf{std::}.} \\

\subsection{Mai mettere using namespace in un header file!}

\textsf{\small Un altro importante problema che può capitare con \textbf{using namespace std} è quello di includerlo in un header file. È DA \textbf{NON} FARE!} \\

\textsf{\small Mettere lo \textbf{using namespace} in un header file costringe chiunque voglia utilizzare la tua libreria ad usare anche \textbf{using namespace}, il che crea un problema quando per esempio l'utente crea una funzione che si trova anche nel namespace.}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/MAI_mettere_USING_negli_header_files.png}
	\caption{Mai mettere using in un header file}
	\label{fig:never_using_in_header}
\end{figure}

\textsf{\small Quindi, meglio mettere \textbf{using namespace} nei files \textbf{.cpp}, ma in generale, come abbiamo detto prima è meglio \textbf{non} utilizzarlo.} \\

\textsf{\small Quindi \textbf{non} mettere \textbf{using namespace} in un header file, neanche \textbf{using namespace std}.} \\

% -------------------------- SECTION: STRUTTURE --------------------------------------

\newpage

\section{Strutture}

\textsf{\small \textbf{Definizione: } Le strutture sono dei tipi di dati definiti dall'utente per raggruppare oggetti di tipi diversi.} 

\textsf{\small Sono usati per rappresentare un record.}

\textsf{\small La keyword \textbf{struct} è usata per creare una struttura.}

\textsf{\small In questo modo semplicemente creiamo la struttura, ma non instanziamo nessun oggetto; per creare una istanza servirà richiamare il nome della struttura e poi il nome dell'istanza.}

\textsf{\small Per accedere ai campi della struttura si potrà usare l'operatore \textbf{.} (punto).}

\begin{lstlisting}
	struct nome_struttura{
		// campi della struttura
		int x;
		double d;
		char stringa[128];
	}; // Da notare il ; alla fine

	// Esempio una struttura per immagazzinare le coordinate di un punto.
	struct Point {
		int x;
		int y;
	};

	// In realtà in C++ non è necessario usare la keyword struct per creare un'istanza, a differenza del C.
	struct Point p1;
	p1.x = 0;
	p1.y = 1;
\end{lstlisting}

\textsf{\small In realtà in C++ non è necessario usare la keyword struct per creare un'istanza, a differenza del C.}

\textsf{\small Inoltre è anche possibile assegnare dei valori di default ai campi della struttura.} \\

\begin{lstlisting}
	#include <iostream>
	
	struct Point{
		int x = 0;
		int y = 1;
	};

	struct Point p1;
	std::cout << p1.x << std::endl; // Output : 0
	std::cout << p1.y << std::endl; // Output : 1
\end{lstlisting}

\subsection{typedef}

\textsf{\small \textbf{Definizione: } La keyword \textbf{typedef} è usata essenzialmente per rinominare una tipologia.}

\textsf{\small Possiamo usare la parola chiave \textbf{typedef} per evitare di scrivere ogni volta struct nome\_della\_struttura per instanziare:} \\

\begin{lstlisting}
	typedef struct Point Punto;
	// Ora possiamo semplicemente scrivere Punto nome\_della\_istanza per creare una nuova istanza, al posto di dover scrivere struct Point nome\_della\_istanza.
	// In questo caso, potrebbe non sembrare molto, ma per strutture con nomi più lunghi è una manna dal cielo.
	
	Punto p1;
	p1.x = 3;
	p1.y = 2;
\end{lstlisting}

\textsf{\small Inoltre, ci sono diversi modi per creare una struttura apparte il modo visto prima, due di questi è attraverso il \textbf{typedef}: } \\

\begin{lstlisting}
	// Altro modo 1
	typedef struct Point {
		int x;
		int y;
	} Point;

	Point p1;
	p1.x = 1;
	p1.y = 0;
	
	// Altro modo 2
	struct Point {
		int x;
		int y;
	} typedef Point;

	Point p1;
	p1.x = 4;
	p1.y = 5;
\end{lstlisting}

\subsection{Funzioni nelle strutture} %TODO: oppure come subsection delle differenze C e C++

\textsf{\small A differenza del C, nelle strutture del C++ è possibile inserire delle funzioni.} \\

\begin{lstlisting}
	#include <iostream>
	
	struct Rettangolo{
		int x;
		int y;
		int area(){
			return x * y;
		}
	};

	int main()
	{
		typedef struct Rettangolo Rettangolo;
		Rettangolo r1;
		r1.x = 3;
		r1.y = 2;
		std::cout << "Area rettangolo: " << r1.area() << std::endl; // Output : Area rettangolo: 6
		return 0;
	}
\end{lstlisting}

\subsection{Strutture nelle strutture}

\textsf{\small È possibile includere delle strutture all'interno di una struttura, come una matriosca.} \\

\begin{lstlisting}
	#include <iostream>
	
	struct Point {
		int x;
		int y;
	};

	// Ovviamente la definizione della struttura Point deve essere fatta prima della struttura Rettangolo se la vogliamo includere in Rettangolo.
	struct Rettangolo{
		Point p;
		int area(){
			return p.x * p.y;
		}
	};

	typedef struct Rettangolo Rettangolo;
	Rettangolo r1;
	r1.p.x = 3;
	r1.p.y = 2;
	std::cout << "Area rettangolo: " << r1.area() << std::endl; // Output : Area rettangolo: 6
\end{lstlisting}

\subsection{Puntatore ad una struttura}

\textsf{\small È possibile far puntare un puntatore ad una struttura.} \\

\textsf{\small Per assegnare un valore ad uno specifico campo della struttura possiamo sia avvalerci dell'operatore \textbf{.} sia dell'operatore \textbf{->} che in questo caso fa esattamente la stessa cosa.} \\

\begin{lstlisting}
	struct Book {
		char  title[50];
		char  author[50];
		char  subject[100];
		int   book_id;
	};

	typedef struct Book Book;
	Book *pBook;
	
	// Possiamo sia fare così..
	(*pBook).title = "Learn C++";
	
	//.. sia fare così
	pBook->title = "Learn C++";
\end{lstlisting}

\subsection{Array di Strutture}

\textsf{\small Ovviamente è possibile creare un array di strutture, dove ogni elemento dell'array è una struttura.} \\

\begin{lstlisting}
	struct Cliente{
		int id;
		char nome[128];
	};

	typedef struct Cliente Cliente;
	
	Cliente clienti[2] = {{0, "Gigi"}, {1, "Pippo"}};
	// Oppure
	clienti[0].id = 0;
	clienti[0].nome = "Gigi";
	
	clienti[1].id = 1;
	clienti[1].nome = "Pippo";
	
	// Oppure si potrebbe anche fare così
	struct Cliente{
		int id;
		char nome[128];
	}cliente1, cliente2;

	cliente1.id = 0;
	cliente1.nome = "Gigi";
	
	cliente2.id = 1;
	cliente2.nome = "Pippo";
	
\end{lstlisting}

\subsection{Strutture come parametri e come ritorno}

\textsf{\small Ovviamente, si possono passare anche le strutture come parametri. Da fare attenzione che se non serve, meglio non copiare un'intera struttura quando la si passa come parametro.}

\begin{lstlisting}
	#include <iostream>
	
	struct Book {
		char  title[50];
		char  author[50];
		char  subject[100];
		int   book_id;
	};
	
	void stampaLibro(struct Book* book){
		std::cout << "Titolo: " << book->title << std::endl;
		std::cout << "Autore: " << book->author << std::endl;
		std::cout << "Soggetto: " << book->subject << std::endl;
		std::cout << "Id: " << book->book_id << std::endl;
	}

	struct Book book1;
	std::strcpy( book1.title, "Learn C++ Programming");
	std::strcpy( book1.author, "Chand Miyan"); 
	std::strcpy( book1.subject, "C++ Programming");
	book1.book_id = 3;
	
	stampa(&book1);
	// Output : Titolo: Learn C++ Programming
	// Output : Autore: Chand Miyan
	// Output : Soggetto: C++ Programming
	// Output : Id: 3
\end{lstlisting}

\textsf{\small Al tempo stesso, si possono restituire strutture dalle funzioni.} \\

\begin{lstlisting}
	#include <iostream>
	
	#define MATERIE 3
	
	struct studente{
		int matricola;
		char nome[128];
		char cognome[128];
		int voti[MATERIE];
		int media;
	};

	typedef struct studente Studente;
	
	// std::cin serve per l'input dell'utente.

	Studente createStudente(){
		Studente s;
		std:: cout << "Inserisci matricola: \n";
		std::cin >> s.matricola;
		
		std:: cout << "Inserisci nome: \n";
		std::cin >> s.nome;
		
		std:: cout << "Inserisci cognome: \n";
		std::cin >> s.cognome;
		
		int sum = 0;
		
		for(int i = 0; i < MATERIE; i++){
			std:: cout << "Inserisci voto: \n";
			std::cin >> s.voti[i];
			sum += s.voti[i];
		}
	
		s.media = sum / MATERIE;
		
		return s;
	}

	int main()
	{
		Studente s = createStudente();
		// Output : quelli inseriti
		std::cout << "Nome: " << s.nome << std::endl;
		std::cout << "Cognome: " << s.cognome << std::endl;
		std::cout << "Voto1: " << s.voti[0] << std::endl;
		std::cout << "Voto2: " << s.voti[1] << std::endl;
		std::cout << "Voto3: " << s.voti[2] << std::endl;
		std::cout << "Media: " << s.media << std::endl;
		return 0;
	}
\end{lstlisting}

\subsection{Strutture in C vs in C++}

\begin{tabular}{|c|c|}
	\hline
	\textbf{Strutture in C} & \textbf{Strutture in C++} \\
	\hline
	\textsf{\small Sono permessi solo membri dati, } & \textsf{\small Sono permessi sia dati } \\
	\textsf{\small non funzioni.} & \textsf{\small sia funzioni membro.} \\
	\hline
	\textsf{\small Non può avere membri statici.} & \textsf{\small Può avere membri statici.} \\
	\hline
	\textsf{\small Non possiamo avere un costruttore.} & \textsf{\small Possiamo avere un costruttore.} \\
	\hline
	\textsf{\small L'inizializzazione diretta dei membri } & \textsf{\small L'inizializzazione diretta dei membri } \\
	\textsf{\small non è possibile.} & \textsf{\small è possibile.} \\
	\hline
	\textsf{\small È necessario usare la  } & \textsf{\small Non è necessario } \\
	\textsf{\small keyword struct per dichiarare una } & \textsf{\small usare la keyword struct.} \\
	\textsf{\small variabile di tipo struct.} & \textsf{\small } \\
	\hline
	\textsf{\small Non supporta access modifiers.} & \textsf{\small Supporta gli access modifiers. } \\
	\textsf{\small } & \textsf{\small (public, private, protected, ecc.)} \\
	\hline
	\textsf{\small Sono permessi soltanto } & \textsf{\small Sono permessi sia i puntatori } \\
	\textsf{\small i puntatori alle strutture.} & \textsf{\small sia le references.} \\
	\hline
	\textsf{\small L'operatore sizeof() genererà 0 } & \textsf{\small L'operatore sizeof() genererà 1 } \\
	\textsf{\small per una struttura vuota.} & \textsf{\small per una struttura vuota.} \\
	\hline
	\textsf{\small Il Data Hiding non è possibile.} & \textsf{\small Il Data Hiding è possibile.} \\
	\hline
\end{tabular}

\subsection{Costruttori e Distruttori nelle Strutture}

\textsf{\small È possibile definire dei \textbf{costruttori} e dei \textbf{distruttori} nelle \textbf{strutture}.} \\

\textsf{\small I \textbf{costruttori} sono delle speciali funzioni con lo stesso nome della struttura che vengono invocate quando un'istanza della struttura viene creata.} \\

\textsf{\small I \textbf{distruttori} sono delle speciali funzioni con lo stesso nome della struttura che servono per deallocare della memoria precedentemente allocata all'interno della struttura.} \\

\textsf{\small Per indicare un \textbf{distruttore} mettiamo davanti al nome della struttura anche \textbf{\textasciitilde} (tilde).} \\

\begin{lstlisting}
	#include <iostream>
	
	struct MyStruct {
		int x;
		// Costruttore con lista di inizializzazione, la variabile y passata al costruttore verrà poi data alla variabile membra x.
		MyStruct(int y) : x(y) {}
		~MyStruct()
		{
			// Corpo del distruttore
		}
	};

	int main()
	{
		struct MyStruct instance(5);
		
		std::cout << instance.x << std::endl; //Output: 5
		
		instance.x = 2;
		
		std::cout << instance.x << std::endl; //Output: 2
		
		return 0;
	}
\end{lstlisting}

\textsf{\small Questi concetti verranno approfonditi nella sezione sulle \emph{Classi}.} \\

% -------------------------- SECTION: UNION ------------------------------------------

\section{Union}

\textsf{\small \textbf{Definizione: } La \textbf{union} è un tipo di struttura dove l'ammontare di memoria è un fattore chiave.} \\

\begin{itemize}
	\item \textsf{\small Come le strutture, le union possono contenere diversi tipologie di variabili.}
	\item \textsf{\small Ogni qualvolta che una nuova variabile è inizializzata dall'union in C sovrascrive quella vecchia, ma in C++ usiamo quella locazione di memoria e non abbiamo bisogno di quella parola chiave.} %TODO: da rivedere.
	\item \textsf{\small È utile quando i dati passati a una funzione sono sconosciuti, utilizzare una \textbf{union} che contiene tutti i possibili tipi può essere il rimedio a questo problema.}
	\item \textsf{\small Utilizziamo la keyword \textbf{union} per crearne una.}
\end{itemize}

\begin{lstlisting}
	#include <iostream>
	
	union nome_della_union {
		// tipi di dati
	}; // Da notare il ; proprio come nelle strutture.

	union var {
		int iVar;
		char cVar;
		float fVar;
	};

	int main()
	{
		// In C++ non serve la keyword union.
		union var V1, V2, V3;
		
		V1.iVar = 33;
		V2.cVar = 33;
		V3.fVar = 33.33;
		
		std::cout << "V1 var: " << V1.iVar << std::endl; // Output : V1 var: 33
		std::cout << "V2 var: " << V2.cVar << std::endl; // Output : V2 var: !
		std::cout << "V3 var: " << V3.fVar << std::endl; // Output : V3 var: 33.33
		
		return 0;
	}
\end{lstlisting}

\subsection{structure vs union}

\begin{tabular}{|c|c|}
	\hline
	\textbf{Structure} & \textbf{Union} \\
	\hline
	\textsf{\small Usa la keyword \textbf{struct}} & \textsf{\small Usa la keyword \textbf{union}}\\
	\hline
	\textsf{\small Quando una variabile è associata } & \textsf{\small Quando una variabile è associata con } \\
	\textsf{\small con una struttura,} & \textsf{\small una union, il} \\
	\textsf{\small il compilatore alloca la memoria } & \textsf{\small  compilatore alloca memoria } \\
	\textsf{\small per ogni membro.} & \textsf{\small considerando lo spazio occupato } \\
	\textsf{\small Lo spazio occupato dalla struttura} & \textsf{\small dal membro più grande.} \\
	\textsf{\small è maggiore o uguale alla somma} & \textsf{\small } \\
	\textsf{\small dello spazio dei suoi membri.} & \textsf{\small } \\
	\hline
	\textsf{\small Per ogni membro della struttura} & \textsf{\small La memoria allocata} \\
	\textsf{\small è assegnato uno } & \textsf{\small è condivisa con i } \\
	\textsf{\small spazio di allocazione unico.} & \textsf{\small membri individuali dalla union.} \\
	\hline
	\textsf{\small Modificare un membro della struttura} & \textsf{\small Modificare un membro della union} \\
	\textsf{\small non modificherà gli altri membri.} & \textsf{\small modificherà gli altri membri.} \\
	\hline
	\textsf{\small I membri individuali possono essere} & \textsf{\small Solo un membro alla volta} \\
	\textsf{\small acceduti ad ogni momento.} & \textsf{\small può essere acceduto.} \\
	\hline
	\textsf{\small Si possono inizializzare } & \textsf{\small Solo il primo membro} \\
	\textsf{\small diversi membri alla volta.} & \textsf{\small della union può essere inizializzato.} \\
	\hline
\end{tabular}

%\textsf{\small } & \textsf{\small } \\ %TODO: remove

% -------------------------- SECTION: CLASSI -----------------------------------------

\newpage

\section{Classi}

\textsf{\small \textbf{Definizione: } La \textbf{classe} è il concetto fondamentale, il pilastro, la trave portante, la pietra miliare della programmazione ad oggetti. È un tipo di dato definito dall'utente che contiene i propri dati e funzioni membro che possono essere acceduti creando un'istanza.} \\ %TODO: si dice la trave portante?

\textsf{\small Una classe è come uno stampino, un modello per creare oggetti. } \\

\textsf{\small È la differenza sostanziale del C++ con il C, l'avere le classi, rendendo il linguaggio: un linguaggio a programmazione di oggetti. } \\ %TODO: questa la portrei riscrivere meglio.

\textsf{\small Ogni classe rappresenta un oggetto che possiede degli attributi, delle caratteristiche (dati) e dei comportamenti, stabiliti dalle funzioni che possiede. } \\

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/class_data_and_behaviour.png}
	\caption{Dati e comportamenti di una classe}
	\label{fig:class_data_and_behaviour}
\end{figure}

\textsf{\small Per creare una classe si utilizza la keyword \textbf{class}. Lo spazio di memoria non è allocata quando la classe viene definita, ma quando viene istanziata. } \\

\textsf{\small Per creare un'istanza della classe, si chiama il nome della classe e poi il nome dell'istanza.} \\

\subsection{Costruttori e Distruttori}

\subsubsection{Costruttori}

\textsf{\small \textbf{Definizione: } Il \textbf{costruttore} è una speciale funzione membro (della classe) che inizializza gli oggetti di una classe. Il costruttore è chiamato automaticamente quando un'istanza della classe viene creata. È una funzione speciale perché non ha tipi di ritorno, o meglio il tipo di ritorno è la classe stessa. } \\ %Funzione membro o membra? Credo funzione membro

\textsf{\small Il nome di questa funzione \textbf{costruttore} è identico al nome della classe stessa.} \\

\textsf{\small Se non specifichiamo un \textbf{costruttore}, uno di default verrà creato dal compilatore (senza parametri e con il corpo della funzione vuoto).} \\

\subsubsection{Initialization List}

\textsf{\small \textbf{Definizione: } La \textbf{Initialization List} è usata per inizializzare i dati membri della classe. Per fare questo aggiungiamo un \textbf{:} (due punti) dopo il costruttore e inizializziamo le variabili e le separiamo da delle virgole.} \\

\textsf{\small Può essere utile per:}

\begin{itemize}
	\item \textsf{\small Chiamare il costruttore della classe base.}
	\item \textsf{\small Inizializzare i membri prima che il costruttore venga eseguito.}
	\item \textsf{\small Per inizializzare i membri const non statici.}
	\item \textsf{\small Per inizializzare dei membri referenze}
	\item \textsf{\small Per inizializzare gli oggetti membri che non hanno un default constructor.}
	\item \textsf{\small Per inizializzare i membri della classe base.}
	\item \textsf{\small Quando il nome del costruttore è lo stesso del dato.}
	\item \textsf{\small Per questioni di performance.}
	%\item \textsf{\small }
\end{itemize}

\begin{lstlisting}
	// Questo codice non andrebbe, perché mVal è const. Non possiamo cambiare il valore di una const nel costruttore perché è segnato come const.
	class Demo {
			// Costruttore
			Demo(int& val)
			{
				mVal = val;
			}
		
			const int& mVal;
	};

	// Questo invece è possibile:
	class Demo {
			// Quindi puoi usare la lista di inizializzazione per fare questo.
			// Costruttore : inizialization list
			Demo(int& val) : mVal(val)
			{
			}
		
			const int& mVal;	
	};
\end{lstlisting}

\subsubsection{Distruttori}

\textsf{\small \textbf{Definizione: } Il \textbf{distruttore}, come dice la parola, è una funzione membro della classe che viene invocata automaticamente quando un oggetto (istanza della classe) viene distrutto/eliminato. Il che significa che il distruttore è l'ultima funzione ad essere chiamata. } \\

\textsf{\small Per definire un \textbf{distruttore} si crea una funzione con lo stesso nome della classe, ma prima del nome deve essere accompagnata dal simbolo \textbf{\textasciitilde} (tilde).} \\

\subsubsection{Proprietà del distruttore}

\begin{itemize}
	\item \textsf{\small Il distruttore è invocato automaticamente quando gli oggetti sono distrutti.}
	\item \textsf{\small Non può essere dichiarato \textbf{static} o \textbf{const}.}
	\item \textsf{\small Il \textbf{distruttore} non ha argomenti.}
	\item \textsf{\small Non ha tipi di ritorno, nemmeno \textbf{void}.}
	\item \textsf{\small Un oggetto della classe con un distruttore non può diventare membro di una \textbf{union}.}
	\item \textsf{\small Un distruttore dovrebbe essere dichiarato nella sezione \textbf{public}.}
	\item \textsf{\small Il programmatore non può accedere all'indirizzo del \textbf{distruttore}.}
	%\item \textsf{\small }
\end{itemize}

\subsubsection{Quando viene chiamato il distruttore?}

\begin{itemize}
	\item \textsf{\small La funzione finisce.}
	\item \textsf{\small Il programma termina.}
	\item \textsf{\small Un blocco contenente le variabili cessa.}
	\item \textsf{\small Un operatore \textbf{delete} viene chiamato.}
\end{itemize}

\begin{lstlisting}
	class MyClass {
		// Costruttore
		MyClass(){
			// Corpo del costruttore.
		}
		// Distruttore
		~MyClass(){
			// Corpo del distruttore.
		}
	}
\end{lstlisting}

\subsection{Access modifiers}

\textsf{\small \textbf{Definizione: } Gli \textbf{Access Modifiers} in una classe sono usati per assegnare l'accessibilità ai membri della classe. Questo permette una importante feature della programmazione ad oggetti, ovvero la \textbf{Data Hiding} che permette di prevenire l'accesso diretto dei dati da parte delle funzioni del programma.} \\

\textsf{\small Ci sono 3 tipi di \textbf{access modifiers}:} \break

\begin{tabular}{|c|c|}
	\hline
	\textbf{Access Modifier} & \textbf{Definizione} \\
	\hline
	\textsf{\small \textbf{public}} & \textsf{\small accessibile a tutti.} \\
	\hline
	\textsf{\small \textbf{private}} & \textsf{\small accessibile solo all'interno della classe stessa.} \\
	\hline
	\textsf{\small \textbf{protected}} & \textsf{\small accessibile solo alla classe, alle sue sottoclassi (ereditarietà)} \\
	\textsf{\small } & \textsf{\small ed alle classi amiche (friend class).} \\
	\hline
\end{tabular}

\subsubsection{Incapsulamento}

\textsf{\small \textbf{Definizione: } L'\textbf{incapsulamento} è un concetto di programmazione ad oggetti che mette assieme i dati e le funzioni che manipolano i dati per mantenerli sicuri da interferenze esterne e da un uso improprio.} \\

\textsf{\small L'\textbf{incapsulamento} dei dati è un meccanismo di impacchetamento di dati e delle funzioni che li usano. } \\

\textsf{\small I dati dovrebbero perciò essere posti come \textbf{private}, mentre le funzioni che manipolano o recuperano questi dati come \textbf{public}.} \\

\textsf{\small La \textbf{Data abstraction} è un meccanismo che espone solo le interfacce e nasconde  i dettagli dell'implementazione dall'utente.} \break

%TODO: qui fare un esempio concreto.

\begin{lstlisting}
	#include <iostream>
	
	class Sommatore {
		// con public sono accessibili da tutti.
	  public:
		// Costruttore.
		Sommatore(int i = 0){ // i = 0 vuol dire che assegniamo un valore di default, casomai l'utente non voglia inserirne uno.
			totale = i;
		}
	
		// Interfaccia al mondo esterno.
		void aggiungiNumero(int numero){
			totale += numero;
		}
	
		// Interfaccia al mondo esterno.
		int getTotale(){
			return totale;
		}
	
	private:
		// Dati nascosti al mondo esterno.
		int totale;
	};

	int main(){
		Sommatore s;
		
		s.aggiungiNumero(3);
		s.aggiungiNumero(6);
		s.aggiungiNumero(9);
		
		std::cout << "Totale: " << s.getTotale() << std::endl; // Output: Totale: 18
		return 0;
	}
\end{lstlisting}

\subsection{scope resolution operator ::}

\textsf{\small L'operatore \textbf{scope resolution} indicato con i \textbf{::} (doppi due punti) può essere usato per definire delle funzioni della classe fuori dalla stessa.} \\

\textsf{\small Può essere usato per accedere ad una variabile globale quando c'è anche una variabile locale con lo stesso nome.} \\

\textsf{\small Può essere usato quando si ha la definizione di una classe all'interno di un'altra classe.} \\

\begin{lstlisting}
#include <iostream>
int weight = 33;
	
class MyClass {
	public:
		MyClass(){
			num = 66;
		}	
	
		void display();
		
		int get_num(){
			return num;
		}
	
	private:
		int num;
};

void MyClass::display(){
	std::cout << "Il valore di num e\': " << get_num() << std::endl;
}

int main(){
	int weight = 99;
	MyClass istanza;
	istanza.display(); // Output: Il valore di num è: 66
	
	std::cout << "Valore della variabile weight locale: " << weight << std::endl;
	std::cout << "Valore della variabile globale: " << ::weight << std::endl; 
	return 0;
}
\end{lstlisting}

\subsection{Getters \& Setters}

\textsf{\small Per via dell'incapsulamento, per poter recuperare (getter) o impostare (settare) le variabili private usufruiamo dei \textbf{getters \& setters} che sono due funzioni, una per recuperare il dato (getter) e l'altro per impostarlo (setter).} \\

\begin{lstlisting}
	class MyClass {
	public:
		MyClass(){
			// Costruttore
		}
	
		// Recupera il valore della variabile number.
		int get_number(){
			return number;
		}
		
		// Imposta un nuovo valore alla variabile number.
		void set_number(int number_t){
			number = number_t;
		}
	
	private:
		int number;
	};
\end{lstlisting}

\subsection{Ereditarietà}

\textsf{\small \textbf{Definizione: } L'\textbf{ereditarietà} è la capacità di derivare le proprietà e le caratteristiche da un'altra classe. È una delle feature più importanti della programmazione ad oggetti.} \\

\textsf{\small La classe che deriva è chiamata \textbf{derived class} o \textbf{sub class}, mentre quella che viene derivata è chiamata \textbf{base class} o \textbf{super class}.} \\

\textsf{\small Per implementare l'ereditarietà usiamo l'operatore \textbf{:} quando andiamo a definire la classe derivata. Questa è chiamata la \textbf{initialization list} serve per chiamare la classe base e per inizializzare le variabili membri prima che il costruttore venga eseguito.} \\

\textsf{\small Questo tipo di relazione è chiamata relazione \textbf{is-a} (è una).} \\

\begin{lstlisting}
	class nome_classe_derivata : modalità_di_accesso nome_classe_base {
		// Corpo della subclass/ derived class
	}
\end{lstlisting}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/animal_class_uml.jpg}
	\caption{Concetto dell'ereditarietà}
	\label{fig:ereditarietà2}
\end{figure}

%TODO: aggiungere classe Monkey
\begin{lstlisting}
	#include <iostream>
	 
	class Animal {
	public:
		Animal(){
			std::cout << "Animal Constructor" << std::endl;
		}
	
		void eat(){
			std::cout << "gnam gnam.." << std::endl;
		}
	
		void sleep(){
			std::cout << "Sleeping zzz.." << std::endl;
		}
	};

	class Dog : public Animal {
	public:
		Dog(std::string name, int weight){
			std::cout << "Dog Constructor" << std::endl;
			// Qui stiamo assegnando i valori dei parametri alle nostre variabili nella classe (quelle in private).
			// Per evitare confusioni potremmo anche chiamare i parametri del costruttore in maniera diversa (tipo: nomeparametro\_t per differenziarlo oppure \_nomeparametro) oppure per differenziare le variabili della classe potremmo aggiungerci la keyword this.
			name = name;
			weight = weight;
		}
	
		void bark(){
			std::cout << "Wuuf Wuuf" << std::endl;
		}
	
		std::string get_name(){
			return name;
		}
	
		int get_weight(){
			return weight;
		}
	
	private:
		std::string name;
		int weight;
	};

	class Cat : public Animal {
		public:
		Cat(std::string name, int weight){
			std::cout << "Cat Constructor" << std::endl;
			// Qui usiamo il puntatore this per far riferimento alle variabili membre della classe al posto di quelle passate come parametro al costruttore.
			this->name = name;
			this->weight = weight;
		}
		
		void meow(){
			std::cout << "Meow Meow" << std::endl;
		}
	
		std::string get_name(){
			return name;
		}
		
		int get_weight(){
			return weight;
		}
		
		private:
		std::string name;
		int weight;
	};

	int main(){
		Dog floki {"floki", 36};
		std::cout << floki.bark() << std::endl;
		std::cout << floki.get_name() << std::endl;
		std::cout << floki.get_weight() << std::endl;
		
		// Output: Animal Constructor
		// Output: Dog Constructor
		// Output: floki
		// Output: 36
		return 0;
	}
\end{lstlisting}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/inheritance_class_uml2.jpg}
	\caption{Ereditarietà in un diagramma UML}
	\label{fig:ereditarietà}
\end{figure}

\subsubsection{this pointer}

\textsf{\small \textbf{Definizione: } La keyword \textbf{this} serve per riferirsi all'oggetto in cui ci troviamo.} \\ %TODO: da rivedere, aggiungere esempio, ecc.

\subsection{Multi-Ereditarietà}

\textsf{\small Il C++ permette l'\textbf{ereditarietà multipla}, quindi una classe può derivare da più classi base. Non è presente invece l'implementazione di interfacce.} \\

\begin{lstlisting}
	#include <iostream>
	
	class A
	{
		public:
		A()  { std::cout << "A's constructor called" << std::endl; }
	};
	
	class B
	{
		public:
		B()  { std::cout << "B's constructor called" << std::endl; }
	};
	
	class C: public B, public A  // Da notare l'ordine.
	{
		public:
		C()  { std::cout << "C's constructor called" << std::endl; }
	};
	
	int main()
	{
		C c;
		// Output: B's constructor called
		// Output: A's constructor called
		// Output: C's constructor called
		return 0;
	}
\end{lstlisting}

\subsection{Forward Declaration}

\textsf{\small \textbf{Definizione: } La \textbf{forward declaration} è quando prima dichiariamo una funzione, una classe, ecc. con la premessa che da qualche parte nel codice più in là ci sarà una definizione di questa funzione, classe, eccetera.} \\

\textsf{\small Può essere utile per aiutare il compilatore per assicurarsi che non ci siano stati errori di spelling o di numero sbagliato di argomenti da passare.} 

\textsf{\small Può essere utile per ridurre il tempo di \emph{build} del programma.}

\textsf{\small Può essere utile per rompere il ciclo delle referenze dove due definizioni si usano a vicenda.} \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/Forward_declaration.png}
	\caption{Forward Declaration}
	\label{fig:forward_declaration}
\end{figure}

%TODO: aggiungere il resto del codice dell'immagine potrebbe essere utile

\subsection{Chiamata a funzione statica e a membro} 

\subsubsection{Static nelle Classi}

\textsf{\small \textbf{Definizione: } Possiamo definire un membro della classe statica attraverso la keyword \textbf{static}. Questo significa che non importa quante istanze della classe vengano create, c'è una sola copia del membro statico.}

\textsf{\small Un membro statico è condiviso da tutti gli oggetti della classe. Se non è presente un'inizializzazione al membro statico, il suo valore di default sarà 0.} \\ 

\textsf{\small Per accedere a questa funzione statica o membro o altro \textbf{non} possiamo utilizzare l'operatore \textbf{.}, ma dobbiamo usufruire dell'operatore \textbf{::} (scope resolution operator) .} \\

\begin{lstlisting}
class MyClass {
	public:
		MyClass(){
			// Costruttore
		}	
	
		// Questo è un esempio, non ho messo l'implementazione della funzione.
		static int calcola_qualcosa() {};
};

int main(){
	MyClass oggetto;
	// Non posso fare oggetto.calcolaQualcosa();
	// Devo fare MyClass::calcola\_qualcosa();
	MyClass::calcola_qualcosa();
	return 0;
}
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/Class__static_type2.png}
	\caption{Chiamata a membro statico}
	\label{fig:class_static_type}
\end{figure}

\subsection{Funzioni e la keyword const}

\textsf{\small Ci sono vari significati che la keyword \textbf{const} assume e fa assumere alla funzione quando si trova in essa.} \\

\textsf{\small Mettendo \textbf{const} nei parametri della funzione, ciò significa che i parametri di quella funzione non possono essere cambiati, perché sono costanti.}

%TODO: esempio

%TODO: const come return type.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/const_as_parameter.png}
	\caption{Const come parametro}
	\label{fig:const_as_parameter}
\end{figure}

\textsf{\small Mentre, la keyword \textbf{const} alla fine della funzione (Const member function in inglese) significa che l'oggetto chiamato da questa funzione non può essere modificato, questo previene modifiche accidentali all'oggetto. } \\

\begin{lstlisting}
	int val = 5;
	
	// Se aggiungessimo una riga per modificare il valore, otterremmo un errore.
	// Inoltre mettere quel const lì esprime l'intento di non cambiare l'oggetto 
	// della funzione.
	int getValue() const
	{
		return val;
	}
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/const_function_class_members.png}
	\caption{Const function class members}
	\label{fig:const_function_class_members}
\end{figure}

\textsf{\small Infine, c'è restituire \textbf{const} come valore di ritorno di una funzione, ma non sembra di molta utilità, tranne per le move-semantics, per lo meno se lo si ritorna per valore, mentre ritornarlo per reference protegge il valore di ritorno dall'essere modificato.} \\

\subsection{Class vs Struct}

\textsf{\small In C++ le classi e le strutture sono simili, ma con alcune differenze:} \break

\begin{tabular}{|c|c|}
	\hline
	\textbf{Class} & \textbf{Struct} \\
	\hline
	\textsf{\small I membri della classe sono } & \textsf{\small I membri di una struttura sono } \\
	\textsf{\small privati da default.} & \textsf{\small pubblici da default.} \\
	\hline
	\textsf{\small L'allocazione della memoria } & \textsf{\small L'allocazione della memoria } \\
	\textsf{\small avviene nell'heap.} & \textsf{\small avviene sullo stack.} \\
	\hline
	\textsf{\small È un tipo di dato per referenza.} & \textsf{\small È un tipo di dato per valore.} \\
	\hline
	\textsf{\small Si dichiara usando la keyword \textbf{class}.} & \textsf{\small Si dichiara usando la keyword \textbf{struct}.} \\
	\hline
	%\textsf{\small } & \textsf{\small } \\
\end{tabular}

% -------------------------- SECTION: CONVENZIONI ------------------------------------

\newpage

\section{Convenzioni del linguaggio}

\textsf{\small \textbf{Definizione: } Le \textbf{convenzioni} sono delle linee guida di un linguaggio che raccomandano un certo stile di programmazione. Queste permettono un codice più chiaro, più leggibile e rende il codice di un software più semplice da mantenere.} \\

\textsf{\small Inoltre, sia il codice che i commenti dovrebbero essere in inglese a differenza di come ho fatto io in questa guida.} \\

\textsf{\small Tratterò in primis le linee guida sui nomi e sul layout, presenti nella sezione di supporto: \emph{NL | Naming and Layout rules} delle \textbf{CppCoreGuidelines}.} \break

% -------------------- NL | NAMING AND LAYOUT RULES ----------------------------------

\subsection{NL | Naming and Layout rules}

\subsubsection{NL.1: Non dire nei commenti quello che può essere semplicemente affermato nel codice}

\textsf{\small I compilatori non leggono i commenti. I commenti sono meno precisi del codice. I commenti non vengono sempre aggiornati in modo costante come il codice.} \\

\subsubsection{NL.2: Indica l'intento nei commenti}

\textsf{\small Il codice dice ciò che è stato fatto, non quello che dovrebbe essere fatto. Spesso l'intento può essere indicato più chiaramente e concisamente che l'implementazione. } \\

\textsf{\small \textbf{Se i commenti e il codice sono in disaccordo, entrambi sono probabilmente errati}.} \\

\subsubsection{NL.3: Mantieni i commenti nitidi}

\textsf{\small La verbosità rallenta la comprensione e rende il codice più difficile da leggere diffondendolo nei sorgenti.} \\

\textsf{\small \textbf{Nota}: Usa l'inglese. Anche se sei madre lingua in un'altra lingua, usa l'inglese in modo che tutti i programmatori possano capire.} \\

\subsubsection{NL.4: Mantieni un'indentazione costante}

\textsf{\small Per via della leggibilità. Per evitare "sciocchi errori".} \\

\textsf{\small \textbf{Nota}: Sempre indentare dopo gli \textbf{if}, \textbf{for}, \textbf{while} è una buona idea.} \\

\subsubsection{NL.5: Evita la codifica delle informazioni sui tipi dei nomi} %TODO: tradurre meglio.

\textsf{\small Se i nomi riflettono i tipi rispetto alle funzionalità, diventerà difficile cambiare i tipi usati per fornire quella funzionalità. Inoltre, se il tipo di una variabile viene cambiato, il codice che la usa dovrà essere anch'esso modificato. Minimizza le conversioni non intenzionali.} \break

\textsf{\small Il seguente è un esempio \textbf{\color{red} ERRATO}\normalcolor:} \\

% frame=single, framexleftmargin=5mm, frame=shadowbox, rulesepcolor=\color{red}

\begin{lstlisting}[frame=single, rulecolor=\color{red}]
	void print_int(int i);
	void print_double(double d);
	void print_string(const char*);
	
	print_int(3);
	print_double(3.69);
	print_string("abc");
\end{lstlisting}

\textsf{\small Il seguente è un esempio \textbf{\color{ForestGreen} CORRETTO}\normalcolor:} \\

\begin{lstlisting}[frame=single, rulecolor=\color{ForestGreen}]
	void print(int i);
	void print(double d);
	void print(string_view);
	
	print(3);
	print(3.69);
	print("abc");
\end{lstlisting}

\textsf{\small \textbf{Nota}: I nomi con i tipi codificati al loro interno sono verbosi e criptici.} \\

\begin{lstlisting}
	printS  // print a std::string
	prints  // print a C-style string
	printi  // print an int
\end{lstlisting}

\textsf{\small Le tecniche come la \emph{notazione Ungherese} sono state usate nei linguaggi \emph{untyped} (senza tipi), ma è generalmente non necessario e persino dannoso in un linguaggio fortemente staticamente-tipizzato come il C++, perché le notazioni non vengono aggiornate e interferiscono con il buon uso del linguaggio.} \\

\subsubsection{NL.7: Fai si che la lunghezza di un nome sia proporzionale alla lunghezza del suo scope (raggio)}

\textsf{\small Più grande è lo scope (raggio), più grande è la possibilità di confusione e di "scontri" tra nomi.} \\

\subsubsection{NL.8: Usa uno stile dei nomi in modo costante}

\textsf{\small La costanza nei nomi e nel loro stile aumenta la leggibilità.} \\

\textsf{\small \textbf{Nota}: Ci sono molti stili, non puoi seguirli tutti, scegline uno, ma lascia lo stile delle librerie importate con il loro stile originale.} \\

\textsf{\small \textbf{Esempio}: Lo \emph{Standard ISO}, usa le lettere minuscole e le cifre, separando le parole con gli underscores (trattini bassi):}

\begin{itemize}
	\item \textsf{\small int}
	\item \textsf{\small vector}
	\item \textsf{\small my\_map}
\end{itemize}

\textsf{\small Evita i doppi trattini bassi: \_\_} \\

\textsf{\small \textbf{Esempio}: Lo \emph{Stroustrup}: ISO Standard, ma con le lettere maiuscole usate per i tipi e i concetti definiti dall'utente. }

\begin{itemize}
	\item \textsf{\small int}
	\item \textsf{\small vector}
	\item \textsf{\small My\_map}
\end{itemize}

\textsf{\small \textbf{Esempio}:\emph{CamelCase}, capitalizza ogni parola in un identificatore multi-parola: }

\begin{itemize}
	\item \textsf{\small int}
	\item \textsf{\small vector}
	\item \textsf{\small MyMap}
	\item \textsf{\small myMap}
\end{itemize}

\textsf{\small Alcune convenzioni capitalizzano la prima lettera, altre no.} \\

\subsubsection{NL.9: Usa ALL\_CAPS (tutte maiuscole) solo per i nomi delle macro}

\textsf{\small Per evitare di confondere le macro con i nomi che obbediscono allo scope (raggio) e regole del tipo.} \\

\textsf{\small \textbf{Nota}: Questa regola si applica anche alle costanti non-macro.} \\

\textsf{\small Applicazioni per assicurarci che venga rispettata: } 

\begin{itemize}
	\item \textsf{\small Segnalare tutte le macro con le lettere minuscole.}
	\item \textsf{\small Segnala tutte le macro che non sono nella forma ALL\_CAPS.}
\end{itemize}

\subsubsection{NL.10: Preferire nomi con lo stile\_underscore (con i trattini bassi)}

\textsf{\small L'utilizzo degli underscores (trattini bassi) per separare parti del nome è originale dello stile del C e del C++ nella \emph{Libreria Standard del C++}.} \\

\textsf{\small \textbf{Nota}: Questa regola è un default soltanto se si ha la possibilità di scelta. Spesso, non si ha la possibilità di scelta e si deve seguire uno stile stabilito per coerenza. Il bisogno di costanza sconfigge il gusto personale.} \\

\textsf{\small \textbf{Esempio} \emph{Stroustrup}: ISO Standard, ma con le lettere maiuscole per i propri tipi e per i concetti: }

\begin{itemize}
	\item \textsf{\small int}
	\item \textsf{\small vector}
	\item \textsf{\small My\_Map}
\end{itemize}

\subsubsection{NL.11: Rendi i letterali leggibili}

\textsf{\small Per la leggibilità del codice.} \\

\textsf{\small \textbf{Esempio} Usa i separatori nelle cifre per evitare lunghe stringhe di cifre.}

\begin{lstlisting}
	auto c = 299'792'458; // m/s2
	auto q2 = 0b0000'1111'0000'0000;
	auto ss_number = 123'456'7890;
\end{lstlisting}

\textsf{\small \textbf{Esempio} Usa suffissi letterali quando necessario per chiarificare.}

\begin{lstlisting}
	auto hello = "Hello!"s; // a std::string
	auto world = "world";   // a C-style string
	auto interval = 100ms;  // using <chrono>
\end{lstlisting}

\textsf{\small \textbf{Nota}: I letterali (literals) non dovrebbero essere sparsi per l'intero codice come "magic constants", ma è comunque una buona idea per renderli chiari quando sono definiti. È semplice fare un typo in una lunga stringa di interi.} \\

\textsf{\small Il seguente è un esempio \textbf{\color{red}ERRATO}\normalcolor:}

\begin{lstlisting}[frame=single, rulecolor=\color{red}]
	#include < chrono >
	
	int main(int argc, char * argv [ ])
	{
		// ...
	}
\end{lstlisting}

\textsf{\small Il seguente è un esempio \textbf{\color{ForestGreen}CORRETTO}\normalcolor:}

\begin{lstlisting}[frame=single, rulecolor=\color{ForestGreen}]
	#include <chrono>
	
	int main(int argc, char* argv[])
	{
		// ...
	}
\end{lstlisting}

\textsf{\small Applicazioni per assicurare il rispetto della regola: }

\begin{itemize}
	\item \textsf{\small Segnalare le lunghe sequenze di cifre. Il problema è definire "lunghe"; forse 7.}
\end{itemize}

\subsubsection{NL.15: Usa gli spazi con moderazione}

\textsf{\small Troppi spazi rendono il testo largo e distraente.} \\

\textsf{\small \textbf{Nota}: Gli spazi bianchi ben piazzati sono un aiuto significativo per la leggibilità. Basta non esagerare.} \\

\subsubsection{NL.16: Usa una convenzionale ordine di dichiarazione della classe}

\textsf{\small Un ordine convenzionale di membri migliora la leggibilità.} \\

\textsf{\small Quando dichiari una classe usa il seguente ordine: } \\

\begin{itemize}
	\item \textsf{\small tipi: classi, enums, aliases (using)}
	\item \textsf{\small costruttori, assegnamenti, distruttore}
	\item \textsf{\small funzioni}
	\item \textsf{\small dati}
\end{itemize}

\textsf{\small Usa l'ordine: \textbf{public} prima di \textbf{protected} prima di \textbf{private}. } \\

\begin{lstlisting}
	class X {
		public:
		// interface
		protected:
		// unchecked function for use by derived class implementations
		private:
		// implementation details
	};
\end{lstlisting}

\textsf{\small \textbf{Esempio} A volte, l'ordine di default dei membri va in conflitto con l'intenzione di separare l'interfaccia pubblica dai dettagli implementativi. In questi casi, i tipi privati e le funzioni possono essere piazzati con i dati privati.} \\

\textsf{\small \textbf{Esempio ERRATO}: Evita di dichiarare molteplici blocchi di accesso dispersi tra blocchi di dichiarazioni con differenti accessi. Il seguente esempio è \textbf{\color{red}ERRATO}\normalcolor: } \\

\begin{lstlisting}[frame=single, rulecolor=\color{red}]
	class X {   // bad
		public:
		void f();
		public:
		int g();
		// ...
	};
\end{lstlisting}

\textsf{\small L'utilizzo di macro per dichiarare gruppi di membri spesso porta a violazioni nelle regole di ordinamento. Comunque, usare le macro oscura quello che è stato espresso. } \\

\textsf{\small Applicazioni per il rispetto della regola: } 

\begin{itemize}
	\item \textsf{\small Segnala le partenze dall'ordine suggerito.}
\end{itemize}

\subsubsection{NL.17: Usa il layout di K\&R }

\textsf{\small Questo è il layout originale del C e C++. Preserva bene lo spazio verticale. Distingue bene i diversi costrutti del linguaggi (come le funzioni e le classi).} \\

\textsf{\small \textbf{Nota}: Nel contesto del C++, questo stile è spesso chiamato \textbf{Stroustrup}.} \\

\textsf{\small \textbf{Esempio}}

\begin{lstlisting}
	struct Cable {
		int x;
		// ...
	};
	
	double foo(int x)
	{
		if (0 < x) {
			// ...
		}
		
		switch (x) {
			case 0:
			// ...
			break;
			case amazing:
			// ...
			break;
			default:
			// ...
			break;
		}
		
		if (0 < x)
		++x;
		
		if (x < 0)
		something();
		else
		something_else();
		
		return some_value;
	}
\end{lstlisting}

\textsf{\small Da notare lo spazio tra \textbf{if} e \textbf{$($}} \\

\textsf{\small \textbf{Nota}: Usa linee separate per per ogni statement, le parentesi di un \textbf{if} e il corpo di un \textbf{for}.} \\

\textsf{\small \textbf{Nota}: La \{ per una \textbf{class} e per una \textbf{struct} non è su una linea separata, ma la \{ per una funzione sì.} \\

\textsf{\small \textbf{Nota}: Capitalizza il nome dei tipi definiti dall'utente per distinguerli dai tipi della libreria standard.} \\

\textsf{\small \textbf{Nota}: Non capitalizzare i nomi delle funzioni.} \\

\textsf{\small Per applicare questa regola, usa un IDE per la formattazione.} \\

\subsubsection{NL.18: Usa il layout dei dichiaratori del C}

\textsf{\small Lo stile di layout del C enfatizza l'uso nelle espressioni e nella grammatica, mentre lo stile del C++ enfatizza i tipi. Questo non vale per le references.} \\ %TODO: "Questo non vale per le references" forse da tradurre meglio.

\textsf{\small \textbf{Esempio}} 

\begin{lstlisting}
	T& operator[](size_t);   // OK
	T &operator[](size_t);   // semplicemente strano
	T & operator[](size_t);   // indeciso
\end{lstlisting}

\subsubsection{NL.19: Evita nomi che possono essere facilmente fraintesi}

\textsf{\small Per la leggibilità. Può capitare di confondere parole simili o errate.} \\

\textsf{\small \textbf{Esempio}}

\begin{lstlisting}
	int oO01lL = 6; // male
	
	int splunk = 7;
	int splonk = 8; // male: splunk e splonk possono essere facilmente confusi
\end{lstlisting}

\subsubsection{NL.20: Non piazzare due dichiarazioni sulla stessa riga}

\textsf{\small Per via della leggibilità. È davvero semplice lasciarsi sfuggire una dichiarazione quando ce ne sono più di una in una linea.} \\

\textsf{\small \textbf{Esempio}}

\begin{lstlisting}
	int x = 8; std::string s = "hello"; // non lo fare
	int x = 8; f(x); ++x; // non lo fare
\end{lstlisting}

\subsubsection{NL.21: Dichiara un nome (solo) per dichiarazione}

\textsf{\small Per la leggibilità. Per minimizzare la confusione con la sintassi.} \\ %sintassi del dichiarante/di dichiarazione.

\textsf{\small \textbf{Nota}: Per i dettagli, guardare \textbf{ES.10} a pag.\textbf{\pageref{ES_10}}.} \\

\subsubsection{NL.25: Non usare void come argomento}

\textsf{\small È verboso, prolisso ed è necessario solo per questioni riguardanti la compatibilità col C.} \\

\textsf{\small \textbf{Esempio}}

\begin{lstlisting}
	void f(void);   // male
	
	void f();       // meglio
\end{lstlisting}

\textsf{\small \textbf{Nota}: Persino Dennis Ritchie (creatore del C) considerava void f(void) un abominio. Lo si poteva fare in C e se lo si fosse vietato avrebbe causato grossi problemi, ma non lo si può usare nel 21° secolo e in C++. } \\

\subsubsection{NL.26: Usa la convenzionale notazione const}

\textsf{\small La notazione convenzionale è più familiare alla maggior parte dei programmatori. È importante per la coerenza nei grandi progetti, community} \\

\textsf{\small \textbf{Esempio}}

\begin{lstlisting}
	const int x = 7;    // OK
	int const y = 9;    // male
	
	const int *const p = nullptr;   // OK, constant pointer to constant int
	int const *const p = nullptr;   // male, constant pointer to constant int
\end{lstlisting}

\textsf{\small \textbf{Nota}: Gli esempi marcati "male" potrebbero sembrare più logici, ma confondono anche più persone, specialmente i principianti.} \break

\textsf{\small Come sempre, ricorda che lo scopo di queste regole di layout è la coerenza, la costanza e che l'estetica varia immensamente.} \\

\begin{comment}
	
	\textsf{\small Elencherò alcune convenzioni che ho trovato ricercando su internet, visto che nelle \textbf{CppCoreGuidelines} non mi è sembrato chiaro che cosa usare: } \\
	
	\textsf{\small Alcune di queste le ho trovate su questa repo:  \href{https://github.com/cpp-best-practices/cppbestpractices/blob/master/03-Style.md}{cppbestpractices style}} \\
	
	\textsf{\small L'importante, di solito, è essere consistenti con ciò che abbiamo scelto di seguire.} \\
	
	\subsection{Stile}
	
	\begin{itemize}
		\item \textsf{\small snake\_case : sembra essere il più usato (è anche usato nella Libreria Standard) (è preferito anche dalle Core Guidelines, a meno che non bisogna seguire lo stile del progetto in cui stiamo lavorando)}
		\item \textsf{\small camelCase (lower camelCase) sembra essere più usato dagli sviluppatori che vengono dal Java}
		\item \textsf{\small PascalCase}
	\end{itemize}
	
	\textsf{\small La \emph{Libreria Standard} (e altre librerie molto conosciute come la libreria \href{https://www.boost.org/}{\textbf{Boost}}) usano queste linee guida: } \\
	
	\begin{itemize}
		\item \textsf{\small Macro usano le maiuscole con gli underscores: INT\_MAX}
		\item \textsf{\small I parametri dei templates usano CamelCase (quello upper, non lower): InputIterator}
		\item \textsf{\small Tutti gli altri nomi usano lo snake\_case: unordered\_map}
	\end{itemize}
	
	\subsection{Convenzioni sui nomi}
	
	\begin{itemize}
		\item \textsf{\small \textbf{Classi} iniziano con la maiuscola: MyClass}
		\item \textsf{\small \textbf{Funzioni} iniziano con la minuscola oppure con gli underscores (trattini bassi): myFunction o my\_function}
		\item \textsf{\small Le \textbf{costanti} e le \textbf{macro} sono tutte in maiuscolo e separate da \_ (trattini bassi): const double PI = 3.14;  (UPPERCASE\_UNDERSCORE\_STYLE)}
	\end{itemize}
	
	\subsection{Dati privati}
	
	\textsf{\small Li distinguiamo ponendo il prefisso \textbf{m\_}, questo sta per "member" (ovvero membro).} \\
	
	\subsection{Distinguere i parametri delle funzioni}
	
	\textsf{\small Si può aggiungere il prefisso \textbf{t\_} nel nome del parametro, questo starebbe per "the" (il/la). Questa linea guida è però controversa.} \\
	
	\subsection{Non iniziare un nome con \_}
	
	\textsf{\small Per evitare di rischiare di collidere con nomi riservati al compilatore e alla \emph{Libreria Standard}.} \\
	
	\subsection{Abilita la build fuori dalle source directories}
	
	\textsf{\small Fai in modo che i files generati vadano in una cartella di output separata dalla cartella dei source (sorgenti).} \\
	
	\subsection{Usa \textbf{nullptr}}
	
	\textsf{\small } \\
	
\end{comment}

\newpage

\textsf{\small Potete trovare tutte le linee guida del linguaggio nelle \textbf{C++ Core Guidelines} : \href{https://github.com/isocpp/CppCoreGuidelines}{CppCoreGuidelines}} \\

%TODO: aggiungere l'immagine CppCoreGuidelines.png

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/CppCoreGuidelines.png}
	\caption{CppCoreGuidelines}
	\label{fig:CppCoreGuidelines}
\end{figure}

% ------------------------------ FINE CAPITOLO ---------------------------------------