% --------------------- LE GEMME DELLA LIBRERIA DEGLI ALGORITMI ----------------------

\chapter{Le gemme degli Algoritmi}

%TODO: Argomenti ancora da trattare in questo capitolo:

%TODO: C++20:
%TODO: ranges, concepts, constrained algorithms, coroutines, template parameter list, modules, ecc..

%TODO: execution policies
%TODO: optionals
%TODO: heap, set, queue, priority_queue
%TODO: std::accumulate, std::any_of, find, search
%TODO: copy_if, copy_n_code
%TODO: std_count, count_if
%TODO: scan, equal code, fill_if, fill_n_code
%TODO: std_generate, inner product, iota, permutations
%TODO: sort
%TODO: lexicographic compare
%TODO: minmax, max, min
%TODO: mismatch
%TODO: std_transform
%TODO: std_unique_code
%TODO: SFINAE e concepts

%TODO: std::clamp
%TODO: normal distribution, uniform real distribution? (non sono in <algorithm> quindi non ha senso metterli qui).

% ----------------------------- SECTION: INTRODUZIONE --------------------------------

\section{Introduzione}

\textsf{\small La libreria degli Algoritmi è di vitale importanza sapere e conoscere bene per ogni buon programma, fornisce delle vere e proprie gemme, per una varietà di scopi: ricerche, ordinamento, contare, manipolare su \emph{ranges} ( un range è una sequenza di oggetti a cui si può accedere attraverso iteratori o puntatori) di elementi. } \\

\textsf{\small Questa libreria è molto vasta, perciò non tratterò proprio tutto tutto, ma una buona parte di essa.} \\

\textsf{\small Inoltre, tratterò anche argomenti al di fuori della libreria, ma che legano con essa e sono molto d'aiuto.} \break

\textsf{\small Qui una lista di argomenti della libreria degli Algoritmi che tratteremo: } \\

%TODO: forse qui dovrei aggiungere anche quelle del C++20.
\begin{itemize}
	\item \textsf{\small \textbf{Operazioni su sequenze non modificabili} }
	\item \textsf{\small \textbf{Operazioni su sequenze modificabili} }
	\item \textsf{\small \textbf{Operazioni di partizionamento} }
	\item \textsf{\small \textbf{Operazioni di Ordinamento} }
	\item \textsf{\small \textbf{Operazioni di ricerca binaria} }
	%\item \textsf{\small \textbf{Altre operazioni di ordinamento sui ranges} }
	\item \textsf{\small \textbf{Operazioni sugli Insiemi} }
	\item \textsf{\small \textbf{Operazioni sugli Heap} }
	\item \textsf{\small \textbf{Operazioni di Min/Max} }
	\item \textsf{\small \textbf{Operazioni di Comparazione} }
	\item \textsf{\small \textbf{Operazioni su permutazioni} }
	\item \textsf{\small \textbf{Operazioni numeriche} }
	%\item \textsf{\small \textbf{Operazioni su Memoria Inizializzata} }
	%\item \textsf{\small \textbf{Execution Policies} }
	%\item \textsf{\small \textbf{} }
\end{itemize}

\textsf{\small La maggior parte di queste sono definite nell'header \textbf{<algorithm>}, ma alcune anche in \textbf{<numeric>}, \textbf{<execution>} ed altre.} \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1.2\textwidth, height=1.2\textheight, keepaspectratio]{./imgs/Algorithm_Library/algorithms.png}
	\caption{Algorithm Library}
	\label{fig:algorithms}
\end{figure}

%TODO: L'importanza della libreria degli algoritmi.
%TODO: Mettere in un itemize la lista di tutte le operazioni: operazioni su sequenze non modificabili, oprazioni su sequeunze modificabili, ecc... (magari in parantesi come è scritto in inglese)
%TODO: dire che non le tratterò proprio tutte tutte, alcune sono molto simili.

%TODO: Inoltre, dire che tratterò argomenti anche che non fanno parte della libreria degli Algoritmi, ma che possono essere utili da utilizzare assieme agli algoritmi.

% ------------------ SECTION: OPERAZIONI SU SEQUENZE NON-MODIFICABILI  ---------------

\newpage

\section{Operazioni su sequenze non-modificabili}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni su sequenze non-modificabili}, da come si intende sono quelle operazioni che non modificano la sequenza, ma che attuano, compiono ricerche per trovare determinati elementi, contano gli elementi, testano varie condizioni, eccetera..} \\

\subsection{Condizioni}

\textsf{\small Possiamo testare se degli elementi sono presenti o no attraverso queste funzioni: \textbf{std::all\_of}, \textbf{std::any\_of}, \textbf{std::none\_of}.} \\

\begin{itemize}
	\item \textsf{\small \textbf{any\_of} : ha bisogno che anche solo 1 sia vero (sia presente).}
	\item \textsf{\small \textbf{all\_of} : ha bisogno che tutti quelli considerati siano veri.}
	\item \textsf{\small \textbf{none\_of} : ha bisogno che nessuno sia presente (tra quelli cercati) (che siano tutti falsi).}
\end{itemize}

\begin{lstlisting}
	#include <iostream>
	#include <vector>
	#include <algorithm>
	
	int main()
	{
		std::vector<int> a = { 6, 1, 7, 3, 2, 5, 4, 9, 12 };
		std::vector<int> b = { 1, 4, 5, 8, 21, 11, 7, 0, 17 };
		
		// Ci assicuriamo che ci sia almeno un valore minore o uguale a 3 nel vettore a.
		std::cout << std::boolalpha << std::any_of( a.cbegin(), a.cend(), [](auto n) {return n <= 3; }) << "\n"; //Output: true
		
		// Ci assicuriamo che non ci siano valori maggiori di 33 nel vettore b.
		std::cout << std::boolalpha << std::none_of( b.cbegin(), b.cend(), [](auto n) { return n > 33; }) << "\n"; //Output: true
		
		std::vector<int> c = {0, 2, 4, 6, 8, 10};
		
		// Controlliamo se tutti i valori sono pari.
		if(std::all_of(c.cbegin(), c.cend(), [](int i){ return i % 2 == 0;}))
		{
			std::cout << "Tutti i numeri sono pari" << "\n";
		}
	
		//Output: Tutti i numeri sono pari.
		
		return 0;
	}	
\end{lstlisting}

\subsection{Ricerca}

\textsf{\small Queste operazioni servono per cercare degli elementi all'interno delle sequenze: \textbf{std::find}, \textbf{std::find\_if}, \textbf{std::find\_if\_not}, \textbf{find\_end}, \textbf{find\_first\_of}, \textbf{adjacent\_find}.} \\

\textsf{\small Inoltre ci sono anche: \textbf{std::search}, \textbf{search\_n}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <string>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO FIND
		std::vector<std::string> a = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
		std::vector<std::string> b = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
		
		// rbegin() e rend() servono per invertire (reverse) l'iteratore.
		const auto k = std::find( a.rbegin(), a.rend(), "one");
		std::cout << "Indice dell'ultimo 'one': " << (a.rend() - k) - 1 << std::endl; //Output: Indice dell'ultimo 'one': 1
		
		// ESEMPIO find\_first\_of
		const std::string s = "one;two,three:four";
		const std::string delimiter = ";,:";
		
		const auto i = std::find_first_of( s.cbegin(), s.cend(), delimiter.cbegin(), delimiter.cend());
		std::cout << "Indice del primo delimitatore: " << i - s.cbegin() << std::endl; //Output: Indice del primo delimitatore: 3
		
		// ESEMPIO adjacent\_find
		const std::string haystack = "as55jsdjflkadfkjsadlfs5j";
		const std::string needle = "s5j";
		
		const auto j = std::adjacent_find( haystack.cbegin(), haystack.cend() );
		std::cout << j - haystack.cbegin() << std::endl; //Output: 2
		
		// ESEMPIO SEARCH
		// Cerchiamo una sequenza nella stringa.
		const auto w = std::search( haystack.begin(), haystack.end(), needle.begin(), needle.end());
		std::cout << w - haystack.begin() << std::endl; //Output: 21
		return 0;
	}
\end{lstlisting}

\textsf{\small Questi sono alcuni esempi dell'utilizzo di questi funzioni, non li faccio tutti, ma gli altri sono intuitivi.} \\

\subsubsection{find vs search}

\textsf{\small La differenza è che \textbf{find} cerca un singolo elemento nella sequenza, mentre \textbf{search} cerca per un'intera sequenza nella sequenza. } \\

\subsection{Contatori}

\textsf{\small Ci sono un paio di funzioni per contare gli elementi di una sequenza: \textbf{std::count}, \textbf{std::count\_if}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		std::vector<int> v = { 8, 4, 9, 2, 3, 6, 5, 5, 1, 2, 4, 9, 1, 2};
		
		std::cout << std::count( v.begin(), v.end(), 3) << std::endl; //Output: 1
		
		std::cout << std::count_if( v.begin(), v.end(), [](auto n) { return n <= 7;}) << std::endl; //Output: 11
		return 0;
	}
\end{lstlisting}

\subsection{Altre operazioni}

\textsf{\small Ulteriori operazioni possibili sono: } \\

\begin{itemize}
	\item \textsf{\small \textbf{mismatch} : restituisce la prima posizione in cui due sequenze differiscono.}
	\item \textsf{\small \textbf{equal} : per controllare se due sequenze sono uguali (lo tratterò anche nelle \emph{Operazioni di Comparazione}).}
	\item \textsf{\small \textbf{is\_permutation} : testa se la sequenza è una permutazione (lo tratterò anche nelle \emph{Operazioni di Permutazione}).}
\end{itemize}

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO MISMATCH
		std::vector<std::string> a = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
		std::vector<std::string> b = { "0", "1", "2", "3", "4", "&", "6", "7", "8", "9", "10" };
		
		const auto i = std::mismatch( a.cbegin(), a.cend(), b.cbegin()).first;
		std::cout << i - a.cbegin() << std::endl; //Output: 5
		
		// ESEMPIO EQUAL
		std::vector<int> v1 = { 1, 2, 3, 4, 5, 6 };
		std::vector<int> v2 = { 1, 2, 3, 4, 5, 6 };
		std::vector<int> v3 = { 1, 2, 4, 3, 5, 6 };
		
		std::cout << std::boolalpha << std::equal( v1.cbegin(), v1.cend(), v2.cbegin()) << std::endl; //Output: true
		std::cout << std::boolalpha << std::equal( v1.cbegin(), v1.cend(), v3.cbegin()) << std::endl; //Output: false
		
		// ESEMPIO IS\_PERMUTATION
		std::vector<int> vec = { 1, 2, 3, 4 };
		std::vector<int> vec2 = { 2, 3, 4, 1 };
		std::vector<int> vec3 = { 2, 3, 2, 2 };
		
		std::cout << std::boolalpha << std::is_permutation(vec.begin(), vec.end(), vec2.begin()) << std::endl; //Output: true
		std::cout << std::boolalpha << std::is_permutation(vec.begin(), vec.end(), vec3.begin()) << std::endl; //Output: false
		return 0;
	}
\end{lstlisting}

\fleuron %TODO: oppure \ornament

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges_seq_non_modificabili}} \\

% ------------------ SECTION: OPERAZIONI SU SEQUENZE MODIFICABILI --------------------

\newpage

\section{Operazioni su sequenze modificabili}

\textsf{\small \textbf{Definizione: } Queste, invece sono quelle operazioni che ti permettono di modificare la sequenza originaria.} \\

\subsection{Copiare sequenze | Copy}

\textsf{\small Queste operazioni ti permettono di copiare parti o intere sequenze: \textbf{std::copy}, \textbf{std::copy\_n}, \textbf{std::copy\_if}, \textbf{std::copy\_backward}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	#include <iterator> // per usare gli iteratori nei loops.
	#include <cctype> // per usare std::isupper.
	
	int main()
	{
		// ESEMPIO COPY\_N
		std::vector<std::string> b = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
		
		std::vector<std::string> c;
		
		c.resize(9);
		
		std::copy_n( b.begin(), 9, c.begin());
		
		// A sto giro devo usare begin() ed end(), non posso usare cbegin() e cend().
		std::cout << "il vettore c contiene: ";
		for (std::vector<std::string>::iterator it = c.begin(); it!=c.end(); ++it)
		{
			std::cout << ' ' << *it;
		}
	
		std::cout << '\n';
	
		//Output: il vettore c contiene: 0 1 2 3 4 5 6 7 8
		
		// ESEMPIO COPY\_N 2
		std::string in = "1234567890";
		std::string out;
		
		std::copy_n(in.begin(), 4, std::back_inserter(out));
		std::cout << out << '\n'; //Output: 1234
		
		// ESEMPIO COPY\_IF
		std::string a = "Solo Le Lettere in Maiuscolo Verranno Considerate";
		
		std::string uppers;
		
		// back\_inserter è uno speciale tipo di \emph{output iterator} per 
		// permettere agli algoritmi che sovrascrivono gli elementi, come il 
		// \emph{copy} di inserire in dei nuovi elementi automaticamente alla fine del container.
		std::copy_if(a.begin(), a.end(), std::back_inserter( uppers ), [](auto s){ return std::isupper(s); } ); // una volta funzionava anche così: std::copy\_if(a.begin(), a.end(), std::back\_inserter( uppers), std::isupper);
		std::cout << uppers << std::endl; //Output: SLLMVC
		
		// ESEMPIO COPY\_BACKWARD
		std::vector<int> inVector;
		for(int i = 0; i < 10; i++)
		{
			inVector.push_back(i);
		}
	
		std::vector<int> outVector(15);
		
		std::copy_backward(inVector.begin(), inVector.end(), outVector.end());
		
		std::cout << "outVector contiene: ";
		for(auto v : outVector){
			std::cout << v << " ";
		}
	
		//Output: outVector contiene: 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9
		return 0;
	}
\end{lstlisting}

\subsection{Muovere | Move}

\textsf{\small Queste ci permettono di spostare gli elementi da una sequenza ad un'altra: \textbf{std::move}, \textbf{std::move\_backward}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <vector>
	#include <string>
	#include <algorithm>
	
	int main()
	{
		std::vector<std::string> a = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
		std::vector<std::string> b = { "0", "1", "2", "3", "4", "&", "6", "7", "8", "9", "10" };
		
		// Sposta i primi due parametri di move nell'inizio del suo terzo parametro.
		std::move( a.begin(), a.begin() + 3, b.begin()); // anche mettendo a.begin() funziona.
		
		std::cout << "il vettore a contiene: ";
		for(auto v : a){
			std::cout << v << " ";
		}
	
		//Output: Il vettore a contiene: three four five six seven eight nine ten
		
		return 0;
	}
\end{lstlisting}

\subsection{Scambiare | Swap}

\textsf{\small Le operazioni di \textbf{swap} ci permettono di scambiare gli elementi di due sequenze, contenitore: \textbf{std::swap}, \textbf{std::swap\_ranges}, \textbf{iter\_swap}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO SWAP
		int x = 5, int y = 12;
		
		std::cout << "x prima dello swap: " << x << ", y prima dello swap: " << y << std::endl; //Output: x prima dello swap: 5, y prima dello swap: 12
		
		std::swap(x,y);
		
		std::cout << "x dopo lo swap: " << x << ", y dopo lo swap: " << y << std::endl; //Output: x dopo lo swap: 12, y dopo lo swap: 5
		
		//ESEMPIO SWAP\_RANGES
		std::vector<int> vec1(7, 66);
		std::vector<int> vec2(7, 18);
		
		std::swap_ranges(vec1.begin() + 1, vec1.end() - 1, vec2.begin());
		
		std::cout << "vec1 contiene: ";
		for(auto v : vec1){
			std::cout << v << " ";
		}
	
		//Output: vec1 contiene: 66 18 18 18 18 18 66
		
		std::cout << '\n';
		
		std::cout << "vec2 contiene: ";
		for(auto v : vec2){
			std::cout << v << " ";
		}
	
		//Output: vec2 contiene: 66 66 66 66 66 18 18
		
		std::cout << '\n';
		return 0;
	}
\end{lstlisting}

\subsection{Trasformare | Transform}

\textsf{\small Applica un'operazione sugli elementi delle sequenze: \textbf{std::transform}.} \\

\textsf{\small \textbf{In Place} : vuol dire che il risultato viene messo nello stesso contenitore non in un altro a parte.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <cctype>
	
	int main()
	{
		// ESEMPIO 1
		std::vector<int> a = { 5, 7, 8, 9, 1, 2};
		std::vector<int> b = { 3, 6, 2, 1, 0, 9};
		
		std::vector<int> c;
		
		std::transform( a.begin(), a.end(), b.begin(), std::back_inserter(c), [](int a, int b) { return a + b * b; });
		
		std::cout << "c contiene: ";
		for(auto v : c)
		{
			std::cout << v << " ";
		}
		
		std::cout << '\n';
		
		//Output: c contiene: 14 43 12 10 1 83
		
		//ESEMPIO 2
		std::string s = "Questa frase verra\' trasformata";
		std::string out;
		
		std::transform( s.begin(), s.end(), std::back_inserter(out), [](auto o){return std::toupper(o);});
		
		std::cout << out << '\n';
		
		//Output: QUESTA FRASE VERRA' TRASFORMATA
		return 0;
	}
\end{lstlisting}

\subsection{Rimpiazzare | Replace}

\textsf{\small Queste permettono di rimpiazzare alcuni elementi della sequenza con altri: \textbf{std::replace}, \textbf{std::replace\_if}, \textbf{std::replace\_copy}, \textbf{std::replace\_copy\_if}.} \\

\begin{lstlisting}
	#include <iostream> // per std::cout
	#include <algorithm> // per std::replace, replace\_if, replace\_copy\_if
	#include <vector> // per std::vector
	#include <array> // per std::array
	#include <iterator> // per std::ostream\_iterator
	#include <functional> // per std::bind
	
	int main()
	{
		// ESEMPIO REPLACE
		std::array<int, 10> arr{3, 2, 1, 7, 8, 6, 11, 9, 0, 33};
		
		std::replace(arr.begin(), arr.end(), 6, 66);
		
		for (int a : arr) {
			std::cout << a << " ";
		}
		std::cout << '\n';
		
		//Output: 3 2 1 7 8 66 11 9 0 33
		
		// ESEMPIO REPLACE\_IF
		// Se è minore di 3 allora lo sostituiamo con 37.
		std::replace_if(arr.begin(), arr.end(), 
		std::bind(std::less<int>(), std::placeholders::_1, 3), 37);
		for (int a : arr) {
			std::cout << a << " ";
		}
		std::cout << '\n';
		
		//Output: 3 37 37 7 8 66 11 9 37 33
		
		// ESEMPIO REPLACE\_COPY\_IF
		std::vector<int> v{6, 1, 22, 66, 3, 9, 8, 1, 4, 5, 7, 0 };
		std::replace_copy_if(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "), [](int n) { return n > 6; }, 33);
		std::cout << '\n';
		
		//Output: 6 1 33 33 3 33 33 1 4 5 33 0
		return 0;
	}
\end{lstlisting}

\subsection{Riempire | Fill}

\textsf{\small Utilizziamo \textbf{std::fill} e \textbf{std::fill\_n} per riempire una sequenza con una serie di elementi.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <iterator>
	
	int main()
	{
		std::vector<int> v(10, 21);
		v.reserve(10);
		std::fill_n( std::back_inserter( v ), 10, 36);
		
		for(auto e : v)
		{
			std::cout << e << " ";
		}
	
		std::cout << '\n';
		
		//Output: 21 21 21 21 21 21 21 21 21 21 36 36 36 36 36 36 36 36 36 36
		return 0;
	}
\end{lstlisting}

\subsection{Generatori | Generate}

\textsf{\small Servono per generare elementi in base ad una funzione generatrice. Questa è definita dall'utente ed è chiamata in modo successivo per assegnare gli elementi, numeri. Queste sono: \textbf{std::generate}, \textbf{std::generate\_n}. } \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <iterator>
	#include <random>
	#include <functional>
	
	int main()
	{
		// ESEMPIO 1
		std::vector<int> v;
		std::generate_n( std::back_inserter(v), 8, [val = 0]() mutable {
			const auto old = val;
			val += 6;
			return old;
		});
	
		for(auto e : v)
		{
			std::cout << e << " ";
		}
		
		std::cout << '\n';
	
		//Output: 0 6 12 18 24 30 36 42
	
		// ESEMPIO 2
		std::vector<int> v2;
		
		std::mt19937 rng( std::random_device{}() );
		std::uniform_int_distribution<int> d(0, 20);
		
		std::generate_n( std::back_inserter(v2), 8, std::bind(d, rng));
		
		for(auto e : v2)
		{
			std::cout << e << " ";
		}
		
		std::cout << '\n';
		
		//Output: 9 6 15 19 14 3 13 8 (pseudo-casuale ogni volta)
		return 0;
	}
\end{lstlisting}

%TODO: generate vs fill (direi non necessario)

\subsection{Rimozione | Remove}

\textsf{\small Come implica dal nome, queste operazioni forniscono un modo per rimuovere elementi da una sequenza: \textbf{std::remove}, \textbf{std::remove\_if}, \textbf{std::remove\_copy}, \textbf{std::remove\_copy\_if}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	#include <cctype>
	
	int main()
	{
		std::string str = " Testo con degli   spazi bianchi";
		
		auto noSpace = std::remove(str.begin(), str.end(), ' ');
		
		std::cout << str << std::endl; //Output: Testocondeglispazibianchibianchi
		
		std::string str2 = "Testo\n con\tdegli   spazi bianchi\n\n";
		str2.erase(std::remove_if(str2.begin(), str2.end(), 
		[](unsigned char c){return std::isspace(c);}), str2.end());
		
		std::cout << str2 << std::endl; //Output: Testocondeglispazibianchi
		return 0;
	}
\end{lstlisting}

\subsection{Unico | Unique}

\textsf{\small Permettono di ottenere una sequenza unica, senza elementi ripetuti.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	#include <iterator>
	
	int main()
	{
		// ESEMPIO UNIQUE
		std::vector<std::string> s = { "0", "1", "2", "2", "2", "3", "5", "4", "6", "9", "9", "5", "11" };
		
		const auto s2 = std::unique(s.begin(), s.end());
		s.erase(s2, s.end());
		
		for(auto e : s)
		{
			std::cout << e << " ";
		}
		
		std::cout << '\n';
		//Output: 0 1 2 3 5 4 6 9 5 11
		
		// ESEMPIO UNIQUE\_COPY
		std::string str1 = "La      stringa    con molti       spazi   bianchi!";
		std::cout << "prima: " << str1 << '\n'; //Output: La      stringa    con molti       spazi   bianchi!
		
		std::string str2;
		std::unique_copy(str1.begin(), str1.end(), std::back_inserter(str2),
		[](char c1, char c2){ return c1 == ' ' && c2 == ' '; });
		
		std::cout << "dopo:  " << str2 << '\n'; //Output: La stringa con molti spazi bianchi!
		return 0;
	}
\end{lstlisting}

\subsection{Invertire | Reverse}

\textsf{\small Queste operazioni consentono di invertire l'ordine delle sequenze: \textbf{std::reverse}, \textbf{std::reverse\_copy}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO REVERSE
		std::vector<int> vec{ 9, 6, 3};
		std::reverse(vec.begin(), vec.end());
		for(auto v : vec) std::cout << v;
		std::cout << '\n';
		//Output: 369
		
		// ESEMPIO REVERSE\_COPY
		std::vector<int> vec2({2, 1, 4});
		
		std::vector<int> reverseVec(3);
		
		std::reverse_copy(std::begin(vec2), std::end(vec2), std::begin(reverseVec));
		for(auto v : reverseVec)
		{
			std::cout << v << " ";
		}
	
		std::cout << '\n';
		//Output: 4 1 2
		return 0;
	}
\end{lstlisting}

\subsection{Ruotare | Rotate}

\textsf{\small Ruotano l'ordine degli elementi nella sequenza: \textbf{std::rotate}, \textbf{std::rotate\_copy}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		std::vector<int> v{3, 7, 9, 8, 2, 1, 0, 10, 4, 5, 12};
		
		// Rotazione verso sinistra
		std::rotate(v.begin(), v.begin() + 1, v.end());
		
		for(auto e : v) std::cout << e << " ";
		std::cout << '\n';
		
		//Output: 7 9 8 2 1 0 10 4 5 12 3
		
		// Rotazione verso destra
		std::rotate(v.rbegin(), v.rbegin() + 1, v.rend());
		
		for(auto e : v) std::cout << e << " ";
		std::cout << '\n';
		
		//Output: 3 7 9 8 2 1 0 10 4 5 12
		return 0;
	}
\end{lstlisting}

\subsection{Spostare | Shift}

\textsf{\small Servono per spostare di tot elementi le sequenze, a differenza della rotazione che si limita a ruotare la sequenza, con lo spostamento si perdono o si ottengono dati.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	
	int main()
	{
		std::vector<std::string>  g{"a", "b", "c", "d", "e", "f", "g"};
		
		std::shift_left( begin(g), end(g), 3 );
		
		for(auto s : g) std::cout << s << " ";
		std::cout << '\n';
		
		//Output: . . . d e f g (in realtà mi dava errore std::shift\_left non è membro di std)
		
		std::shift_right( begin(g), end(g), 3);
		for(auto s : g) std::cout << s << " ";
		std::cout << '\n';
		
		//Output: . . . d . . . (in realtà mi dava errore std::shift\_right non è membro di std)
		
		return 0;
	}
\end{lstlisting}

\subsection{Mischiare | Shuffle}

\textsf{\small Serve per mischiare, mescolare gli elementi della sequenza: \textbf{std::shuffle}, \textbf{std::random\_shuffle}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	#include <random>
	
	int main()
	{
		std::vector<std::string> a = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
		
		std::mt19937 rng( std::random_device{}());
		std::shuffle( a.begin(), a.end(), rng );
		
		for(auto s : a) std::cout << s << " ";
		std::cout << '\n';
		
		//Output: three zero four two ten one nine seven six eight five (è sempre diversa perché è casuale)
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges_seq_modificabili}} \\

% ---------------------- SECTION: OPERAZIONI SU PARTIZIONI ---------------------------

\section{Operazioni su Partizioni}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni su partizioni} permettono di eseguire partizioni sulle sequenze di elementi.} \\

\textsf{\small Queste operazioni possibili sono: \textbf{std::partition}, \textbf{std::is\_partitioned}, \textbf{std::stable\_partition}, \textbf{std::partition\_copy}, \textbf{std::partition\_point}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <array>
	
	int main()
	{
		// ESEMPIO PARTITION
		std::vector<std::string> a = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
		std::vector<int> b = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
		
		auto partion1 = std::partition( a.begin(), a.end(), [](const auto& s) { return std::any_of( s.begin(), s.end(), []( char c){ return c == 'e'; });});
		
		for(auto p : a)
		{
			std::cout << p << " ";
		}
	
		std::cout << '\n';
		
		//Output: zero one ten three nine five eight seven six four two
		
		auto partition2 = std::partition( b.begin(), b.end(), [](int i) { return i % 2 == 0;});
		
		for(auto p : b)
		{
			std::cout << p << " ";
		}
		
		std::cout << '\n';
		
		//Output: 0 10 2 8 4 6 5 7 3 9 1
		
		// ESEMPIO STABLE\_PARTITION
		std::vector<std::string> c = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
		std::vector<int> d = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
		
		auto partion3 = std::stable_partition( a.begin(), a.end(), [](const auto& s) { return std::any_of( s.begin(), s.end(), []( char c){ return c == 'e'; });});
		
		for(auto p : c)
		{
			std::cout << p << " ";
		}
		
		std::cout << '\n';
		
		//Output: zero one two three four five six seven eight nine ten
		
		auto partition4 = std::stable_partition( b.begin(), b.end(), [](int i) { return i % 2 == 0;});
		
		for(auto p : d)
		{
			std::cout << p << " ";
		}
		
		std::cout << '\n';
		
		//Output: 0 1 2 3 4 5 6 7 8 9 10
		
		//ESEMPIO IS\_PARTITIONED
		std::vector<int> v = { 2, 4, 8, 6, 0, 10};
		bool isPartitioned = std::is_partitioned( v.begin(), v.end(), [](int i){ return i % 2 == 0; });
		
		std::cout << std::boolalpha << isPartitioned << std::endl; //Output: true
		
		// ESEMPIO PARTITION\_COPY
		int arr [10] = {1,2,3,4,5,6,7,8,9,10};
		int trueArr [5] = {0};
		int falseArr [5] = {0};
		
		std::partition_copy(std::begin(arr), std::end(arr), std::begin(trueArr), std::begin(falseArr), [](int i){return i > 5; });
		
		for(int a : trueArr)
		{
			std::cout << a << " ";
		}
		
		std::cout << '\n';
		
		//Output: 6 7 8 9 10
		
		for(int a : falseArr)
		{
			std::cout << a << " ";
		}
		
		std::cout << '\n';
		
		//Output: 1 2 3 4 5
		
		// ESEMPIO PARTITION\_POINT
		std::array v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
		auto is_even = [](int i){ return i % 2 == 0; };
		const auto parPoint = std::partition_point(v.cbegin(), v.cend(), is_even);
		const auto i = std::distance(v.cbegin(), pp);
		std::cout << "Partition point a: " << i << "; v[" << i << "] = " << *pp << '\n'; //Output: Partition point a: 4; v[4] = 5
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% --------------------- SECTION: OPERAZIONI DI ORDINAMENTO ---------------------------

\newpage

\section{Operazioni di Ordinamento}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni di ordinamento} consentono di ordinare le sequenze.} \\

\textsf{\small Queste sono: \textbf{std::sort}, \textbf{std::stable\_sort}, \textbf{std::partial\_sort}, \textbf{std::partial\_sort\_copy}, \textbf{std::is\_sorted}, \textbf{std::is\_sorted\_until}, \textbf{std::nth\_elemeent}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	
	int main()
	{
		// ESEMPIO SORT E IS\_SORTED
		std::vector<int> v{ 7, 9, 1, 0, 2, 5, 3, 4, 8, 10, 6};
		
		std::cout << std::boolalpha << std::is_sorted(v.begin(), v.end()) << '\n'; //Output: false
		
		std::sort(v.begin(), v.end());
		
		for(auto e : v)
		{
			std::cout << e << " ";
		}
	
		std::cout << '\n';
		
		//Output: 0 1 2 3 4 5 6 7 8 9 10
		
		std::cout << std::boolalpha << std::is_sorted(v.begin(), v.end()) << '\n'; //Output: true
		
		// ESEMPIO SORT 
		// Il sort, di solito usa il minore < per fare l'ordinamento, ma in questo caso noi gli passiamo il maggiore >.
		std::sort(v.begin(), v.end(), std::greater<int>{});
		
		for(auto e : v)
		{
			std::cout << e << " ";
		}
		
		std::cout << '\n';
		
		//Output: 10 9 8 7 6 5 4 3 2 1 0
		
		// ESEMPIO STABLE\_SORT
		class Employee {
			public:
				int age;
				std::string name;  // Non partecipa nei paragoni
		};
		
		// Questo ci serve per indicare alle funzioni sort come devono fare il paragone per ordinare gli elementi.
		bool operator<(const Employee & lhs, const Employee & rhs)
		{
			return lhs.age < rhs.age;
		}
	
		std::vector<Employee> employees =
		{ 
			{22, "Gigi"},
			{37, "Maria"},
			{48, "Alessio"},
		};
	
		std::stable_sort(v.begin(), v.end());
		
		for (const Employee & e : employees)
			std::cout << e.age << ", " << e.name << '\n';
			
		//Output: 22, Gigi
		//Output: 37, Maria
		//Output: 48, Alessio
		
		// ESEMPIO PARTIAL\_SORT
		std::vector<int> v2 = { 5, 7, 1, 0, 3, 5, 6, 4, 7, 8, 10, 2 };
		
		// Ordina solo una parte del contenitore, non tutto.
		// Può essere utile, magari per delle classifiche, dove magari servono soltanto i primi 10 o i primi 100 giocatori e non tutti gli altri.
		std::partial_sort(v2.begin(), v2.begin() + 4, v2.end());
		
		for(auto& v : v2)
		{
			std::cout << v << " ";
		}
	
		std::cout << '\n';
		
		//Output: 0 1 2 3 7 5 6 5 7 8 10 4 (i primi 4 elementi sono ordinati: 0 1 2 3, tutti gli altri son rimasti in posizioni non ordinate)
		
		// ESEMPIO NTH\_ELEMENT
		std::vector<int> v3{11, 7, 9, 4, 2, 2, 6, 7, 9, 3, 7, 7};
		
		auto m = v3.begin() + v3.size()/2;
		std::nth_element(v3.begin(), m, v3.end());
		
		for(auto& e : v3)
		{
			std::cout << e << " ";
		}
		
		std::cout << '\n';
		
		//Output: 6 2 3 4 2 7 7 7 9 9 7 11
		
		std::cout << "The medianIl mediano è: " << v3[v3.size()/2] << '\n'; //Output: Il mediano è 7
		
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ------------ SECTION: OPERAZIONI DI RICERCA BINARIA (BINARY SEARCH) ----------------

\newpage

\section{Operazioni di Ricerca Binaria}

\textsf{\small \textbf{Definizione: } Queste servono per operazioni su ricerche binarie: \textbf{std::lower\_bound}, \textbf{std::upper\_bound}, \textbf{std::equal\_range}, \textbf{std::binary\_search}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO LOWER\_BOUND
		std::vector<int> v{ 15, 5, 22, 11, 33, 7, 88, 0, 9, 1, 4, 26, 52 };
		
		// Restituisce un iteratore che punta al primo elemento che non è minore del valore.
		const int lowerBound = 3;
		const auto i = std::lower_bound(v.begin(), v.end(), lowerBound);
		
		std::cout << *i << '\n'; //Output: 15
		
		// ESEMPIO UPPER\_BOUND
		// Restituisce un iteratore che punta al primo elemento che è maggiore del valore.
		const int upperBound = 7;
		const auto j = std::upper_bound(v.begin(), v.end(), upperBound);
		
		std::cout << *j << '\n'; //Output: 22
		
		// ESEMPIO EQUAL\_RANGE
		std::vector<int> v = { 11, 10, 33, 33, 33, 111, 10,
			333, 369, 77, 77, 80 };
		
		// Dichiariamo un iteratore per il
		// valore di ritorno di std::equal\_range
		std::pair<std::vector<int>::iterator,
		std::vector<int>::iterator> it;
		
		std::sort(v.begin(), v.end());
		// v diventa 10 10 11 33 33 33 77 77 80 111 333 369
		
		// Usiamo std::equal\_range e compariamo gli elementi
		// con 33
		it = std::equal_range(v.begin(), v.begin() + 12, 33);
		
		// Displaying the subrange bounds
		std::cout << "33 è presente nel vettore dall'indice: "
		<< (it.first - v.begin()) << " fino a: "
		<< (it.second - v.begin());
		
		//Output: 33 è presente nel vettore dall'indice: 3 fino a: 6
		
		// ESEMPIO BINARY\_SEARCH
		std::vector<int> haystack {1, 3, 7, 5, 9};
		std::vector<int> needles {7, 2, 3};
		
		for (auto needle : needles) {
			std::cout << "Cerco il: " << needle << '\n';
			if (std::binary_search(haystack.begin(), haystack.end(), needle)) {
				std::cout << "Trovato " << needle << '\n';
			} else {
				std::cout << "Non trovato!\n";
			}
		}
	
		//Output: Cerco il: 7
		//Output: Trovato
		//Output: Cerco il: 2
		//Output: Non trovato!
		//Output: Cerco il: 3
		//Output: Trovato
		
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% --------------- SECTION: ALTRE OPERAZIONI DI ORDINAMENTO SUI RANGES ----------------

%TODO: questa parte nella sezione sul C++20

% -------------------------- SECTION: OPERAZIONI DI MERGE ----------------------------

\newpage

\section{Operazioni di Fusione | Merge}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni di merge} permettono di combinare, di fondere gli elementi di due sequenze: \textbf{std::merge}, \textbf{std::inplace\_merge}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <random>
	#include <functional>
	
	int main()
	{
		// ESEMPIO MERGE
		std::random_device rd;
		std::mt19937 mt(rd());
		std::uniform_int_distribution<> distribution(0, 9);
		
		std::vector<int> v1(10), v2(10);
		std::generate(v1.begin(), v1.end(), std::bind(distribution, std::ref(mt)));
		std::generate(v2.begin(), v2.end(), std::bind(distribution, std::ref(mt)));
		
		std::cout << "Prima del sorting" << '\n';
		
		for(auto& v : v1)
		{
			std::cout << v << " ";
		}
		std::cout << '\n';
		
		for(auto& v : v2)
		{
			std::cout << v << " ";
		}
		std::cout << '\n';
		
		//Output: Prima del sorting
		//Output: 5 6 1 8 4 9 2 5 2 2 (numeri generati casualmente)
		//Output: 6 0 6 5 7 8 8 2 8 5 (numeri generati casualmente)
		
		std::sort(v1.begin(), v1.end());
		std::sort(v2.begin(), v2.end());
		
		std::cout << "Dopo il sorting" << '\n';
		
		for(auto& v : v1)
		{
			std::cout << v << " ";
		}
		std::cout << '\n';
		
		for(auto& v : v2)
		{
			std::cout << v << " ";
		}
		std::cout << '\n';
		
		//Output: Dopo il sorting
		//Output: 1 2 2 2 4 5 5 6 8 9 
		//Output: 0 2 5 5 6 6 7 8 8 8
		
		std::vector<int> v3;
		std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(v3));
		
		std::cout << "v3 contiene: ";
		
		for(auto& v : v3)
		{
			std::cout << v << " ";
		}
		std::cout << '\n';
		
		//Output: v3 contiene: 0 1 2 2 2 2 4 5 5 5 5 6 6 6 7 8 8 8 8 9 (numeri generati casualmente)
		
		// ESEMPIO INPLACE\_MERGE
		int first[] = {7, 36, 12, 24, 8};
		int second[] = {57, 94, 14, 67, 80};
		
		std::vector<int> v(10);
		
		std::vector<int>::iterator it;
		
		std::sort (first,first+5);
		std::sort (second,second+5);
		
		it = std::copy (first, first+5, v.begin()); 
		std::copy (second,second+5,it);
		
		std::inplace_merge (v.begin(),v.begin()+5,v.end());
		
		std::cout << "Il vettore risultante contiene: ";
		for (it=v.begin(); it!=v.end(); ++it)
		{
			std::cout << ' ' << *it; 
		}
		std::cout << '\n';
		
		//Output: Il vettore risultante contiene:  7 8 12 14 24 36 57 67 80 94
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ------------------------ SECTION: OPERAZIONI SUGLI INSIEMI -------------------------

\newpage

\section{Operazioni sugli Insiemi}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni sugli insiemi} permettono di attuare le tipiche operazioni matematiche: \emph{unione} : \textbf{std::set\_union}, \emph{intersezione} : \textbf{std::set\_intersection}, \emph{differenza} : \textbf{std::set\_difference}, \emph{simmetria differenza} : \textbf{std::set\_symmetric\_difference}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	
	// Funzione per mostrare gli elementi di un std::vector
	template<typename T>
	void printVec(const std::vector<T>& v)
	{
		for(const auto& i : v)
		{
			std::cout << i << " ";
		}
		std::cout << '\n';
	}
	
	int main()
	{
		// ESEMPIO INCLUDES
		std::vector<char> v1 = { 'a', 'b', 'c', 'd', 'f', 'g' };
		std::vector<char> v2 = { 'a', 'b', 'c' };
		std::vector<char> v3 = { 'a', 'c' };
		
		printVec(v1);
		std::cout << "include: " << '\n';
		
		printVec(v2);
		
		std::cout << std::boolalpha << std::includes(v1.begin(), v1.end(), v2.begin(), v2.end()) << '\n'; //Output: true
		
		printVec(v3);
		
		std::cout << std::boolalpha << std::includes(v1.begin(), v1.end(), v3.begin(), v3.end()) << '\n'; //Output: false
		
		std::cout << std::flush;
		
		// ESEMPIO SET\_UNION, SET\_INTERSECTION, SET\_DIFFERENCE, SET\_SYMMETRIC\_DIFFERENCE
		std::vector<int> vec1{ 1, 2, 3, 5, 7, 9 };
		std::vector<int> vec2{ 6, 4, 1, 2, 3, 9, 11 };
		
		std::sort(vec1.begin(), vec1.end());
		std::sort(vec2.begin(), vec2.end());
		
		std::vector<int> destUnion;
		
		std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(destUnion));
		
		std::cout << "unione: ";
		printVec(destUnion); //Output: unione: 1 2 3 4 5 6 7 9 11
		
		std::vector<int> destIntersection;
		
		std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(destIntersection));
		
		std::cout << "intersezione: ";
		printVec(destIntersection); //Output: intersezione: 1 2 3 9
		
		std::vector<int> destDifference;
		
		std::set_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(destDifference));
		
		std::cout << "differenza: ";
		printVec(destDifference); //Output: differenza: 5 7
		
		std::vector<int> destSymmDifference;
		
		std::set_symmetric_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(destSymmDifference));
		
		std::cout << "differenza simmetrica: ";
		printVec(destSymmDifference); //Output: differenza simmetrica: 4 5 6 7 11 
		
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ------------------------- SECTION: OPERAZIONI SU HEAP ------------------------------

\newpage

\section{Operazioni su Heap}

\textsf{\small \textbf{Definizione: } L'\textbf{Heap} è una \emph{struttura dati} basata sugli \emph{alberi} che soddisfa la \textbf{proprietà degli heap}: } \\

\textsf{\small In un \textbf{max heap}: } \\

\begin{itemize}
	\item \textsf{\small le chiavi (il valore) di ciascun nodo padre son sempre maggiori o uguali a quelle dei nodi figli.}
	\item \textsf{\small La chiave (il valore) dal valore massimo appartiene alla radice (detta \emph{root node}).}
\end{itemize}

\textsf{\small In un \textbf{min heap}: } \\

\begin{itemize}
	\item \textsf{\small Le chiavi (il valore) di ciascun nodo sono minori o uguali a quelle dei figli.}
	\item \textsf{\small La chiave del valore minimo appartiene alla radice. }
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{./imgs/Algorithm_Library/Max-Heap.png}
	\caption{Max Heap}
	\label{fig:max-heap}
\end{figure}

\textsf{\small Le operazioni disponibili sugli heap sono: \textbf{std::push\_heap}, \textbf{std::pop\_heap}, \textbf{std::make\_heap}, \textbf{std::sort\_heap}, \textbf{std::is\_heap}, \textbf{std::is\_heap\_until}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <random>
	#include <functional>
	
	// Funzione per mostrare gli elementi di un std::vector
	template<typename T>
	void printVec(const std::vector<T>& v)
	{
		for(const auto& i : v)
		{
			std::cout << i << " ";
		}
		std::cout << '\n';
	}
	
	int main()
	{
		// ESEMPIO MAKE\_HEAP, SORT\_HEAP
		std::mt19937 rng{ std::random_device{}() };
		std::uniform_real_distribution<float> dist{0.0f, 99.0f};
		auto rnd = std::bind(dist, rng);
		
		std::vector<int> v( 22 );
		std::generate_n( v.begin(), v.size(), rnd);
		
		std::make_heap( v.begin(), v.end()); // se qui avessi messo std::make\_heap( v.begin(), v.end(), std::greater<int>{}); avremmo fatto un min-heap
		std::sort_heap( v.begin(), v.end());
		
		printVec(v); //Output: 2 2 8 15 23 23 30 38 52 53 64 64 64 66 68 71 73 74 77 78 87 92
		
		// ESEMPIO IS\_HEAP, MAKE\_HEAP
		
		std::vector<int> v2 = { 7, 12, 8, 9, 18, 36, 44, 52, 90, 11, 5};
		
		printVec(v2); //Output: 7 12 8 9 18 36 44 52 90 11 5
		
		std::cout << std::boolalpha << "is_heap: " << std::is_heap(v2.begin(), v2.end()) << '\n'; //Output: is\_heap: false
		
		if(!std::is_heap(v2.begin(), v2.end()))
		{
			std::make_heap(v2.begin(), v2.end(), std::greater{}); // Col std::greater faccio un min heap.
		}
	
		printVec(v2); //Output: 5 7 8 9 11 36 44 52 90 12 18
	
		std::cout << std::boolalpha << "is_heap: " << std::is_heap(v2.begin(), v2.end()) << '\n'; //Output: is\_heap: true
		
		// ESEMPIO PUSH\_HEAP, POP\_HEAP
		
		std::vector<int> v3 = { 8, 10, 4, 7, 5, 6, 3, 1, 0, 2};
		
		std::make_heap(v3.begin(), v3.end());
		
		v3.push_back(9);
		
		std::cout << "Prima del push_heap: ";
		printVec(v3); //Output: Prima del push\_heap: 10 8 6 7 5 4 3 1 0 2 9
		
		std::push_heap(v3.begin(), v3.end());
		
		std::cout << "Dopo il push_heap: ";
		printVec(v3); //Output: Dopo il push\_heap: 10 9 6 7 8 4 3 1 0 2 5
		
		std::pop_heap(v3.begin(), v3.end());
		std::cout << "Dopo la pop_heap: ";
		printVec(v3); //Output: Dopo la pop\_heap: 9 8 6 7 5 4 3 1 0 2 10 (abbiamo rimosso l'ultimo elemento)
		
		// ESEMPIO IS\_HEAP\_UNTIL
		std::vector<int> v4{2,6,9,3,8,4,5,1,7};
		
		std::sort(v4.begin(),v4.end());
		std::reverse(v4.begin(),v4.end());
		
		auto last = std::is_heap_until (v4.begin(),v4.end());
		
		std::cout << "I primi " << (last - v4.begin()) << " elementi sono un heap valido: ";
		printVec(foo); //Output: I primi 9 elementi sono un heap valido: 9 8 7 6 5 4 3 2 1
		
		return 0;
	}
\end{lstlisting}

% ------------------------- SECTION: OPERAZIONI DI MIN/MAX ---------------------------

\newpage

\section{Operazioni di Min/Max}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni di min/max} servono per ottenere il minimo o il massimo da una data espressione: \textbf{std::max}, \textbf{std::min}, \textbf{std::minmax}, \textbf{std::min\_element}, \textbf{std::max\_element}, \textbf{std::minmax\_element}, \textbf{std::clamp}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	
	int main()
	{
		// ESEMPIO MIN, MAX
		const int a = 25;
		const int b = 82;
		
		std::cout << "Elemento minore: " << std::min(a, b) << std::endl; //Output: 25
		std::cout << "Elemento maggiore: " << std::min(a, b) << std::endl; //Output: 82
		
		// ESEMPIO MINMAX
		int x = 18;
		int y = 22;
		
		auto mm = std::minmax( x, y );
		
		std::cout << mm.first << std::endl; //Output: 18
		std::cout << mm.second << std::endl; //Output: 22
		
		// Oppure si poteva fare anche:
		
		auto[min, max] = std::minmax(x,y); // Se usiamo la reference, auto\&[min, max] a delle temporanee ci porterà ad un \emph{undefined behaviour}.
		
		std::cout << min << std::endl; //Output: 18
		std::cout << max << std::endl; //Output: 22
		
		// ESEMPIO MIN\_ELEMENT, MAX\_ELEMENT, MINMAX\_ELEMENT
		std::vector<int> v = { 8, 77, 42, 54, 3};
		
		auto minElement = std::min_element( v.begin(), v.end() );
		
		std::cout << "Elemento minore: " << minElement << std::endl; //Output: 3
		
		auto maxElement = std::max_element( v.begin(), v.end() ); 
		
		std::cout << "Elemento maggiore: " << maxElement << std::endl; //Output: 77
		
		auto minMaxElement = std::minmax_element(v.begin(), v.end());
		
		std::cout << "Elemento minore con minmax: " << minMaxElement.first << std::endl; //Output: 3
		
		std::cout << "Elemento maggiore con minmax: " << minMaxElement.second << std::endl; //Output: 77
		
		// ESEMPIO CLAMP
		// Blocca, fissa il valore dentro i boundaries
		// In questo caso il valore è 1.5f ed i boundaries sono tra 0.0f e 1.0f
		// 1.5f supera il boundary sopra lo 1.0 quindi il valore della variabile sarà 1.0f
		auto clamped = std::clamp(1.5f, 0.0f, 1.0f);
		
		std::cout << clamped << std::endl; //Output: 1
		
		clamped = std::clamp(-2.0f, 0.0f, 1.0f);
		
		std::cout << clamped << std::endl; //Output: 0
		
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ----------------------- SECTION: OPERAZIONI DI COMPARAZIONE ------------------------

\newpage

\section{Operazioni di Comparazione}

\textsf{\small \textbf{Definizione: } Queste operazioni ci permettono di comparare elementi delle sequenze: \textbf{std::equal}, \textbf{std::lexicographical\_compare}, \textbf{std::lexicographical\_compare\_three\_way}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	#include <string_view>
	
	// ESEMPIO EQUAL
	// Palindromo: sequenza di caratteri, che letta al contrario, rimane invariata.
	// std::string\_view serve per evitare di copiare dati che sono già posseduti da qualche altra parte.
	bool isPalindrome(const std::string_view& s)
	{
		return std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin());
	}
	
	void check(const std::string_view& s)
	{
		std::cout << s << (isPalindrome(s) ? " è" : " non è")
		<< " un palindromo\n";
	}
	
	int main()
	{
	
		check("ANNA"); //Output: ANNA è un palindromo
		
		// ESEMPIO LEXICOGRAPHICAL\_COMPARE
		std::vector<std::string> a = { 7, 9, 0, 8, 5 };
		std::vector<std::string> b = { 7, 9, 8, 0, 5 };
		
		std::cout << std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end()) << std::endl; //Output: false
		
		// ESEMPIO LEXICOGRAPHICAL\_COMPARE 2
		std::vector<std::string> v1 = {"One", "Two", "Three"};
		std::vector<std::string> v2 = {"one", "two", "three"};
		
		bool compare = std::lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end());
		
		std::cout << (compare ? "v1 è minore di v2" : "v1 non è minore di v2") << std::endl; //Output: v1 è minore di v2
		
		v1[0] = "two";
		
		compare = std::lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end());
		
		std::cout << (compare ? "v1 è minore di v2" : "v1 non è minore di v2") << std::endl; //Output: v1 non è minore di v2
		
		return 0;
	}
\end{lstlisting}

%TODO: volendo aggiungere un esempio per std::lexicographical_compare_three_way

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ---------------------- SECTION: OPERAZIONI SU PERMUTAZIONI -------------------------

\newpage

\section{Operazioni su Permutazioni}

\textsf{\small \textbf{Definizione: } Queste servono per usufruire di operazioni su permutazioni: \textbf{std::is\_permutation}, \textbf{std::next\_permutation}, \textbf{std::prev\_permutation}.} \\

\textsf{\small Una \textbf{permutazione} è un modo di ordinare in successione degli oggetti distinti.} \\

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <string>
	
	int main()
	{
		// ESEMPIIO IS\_PERMUTATION
		std::string s1 = "abcd";
		std::string s2 = "bdac";
		std::string s3 = "bdbc";
		
		std::cout << std::boolalpha << std::is_permutation(s1.begin(), s1.end(), s2.begin()) << std::endl; //Output: true
		
		std::cout << std::boolalpha << std::is_permutation(s1.begin(), s1.end(), s3.begin()) << std::endl; //Output: false
		
		// ESEMPIO PREV\_PERMUTATION, NEXT\_PERMUTATION
		std::cout << s1 << std::endl; //Output: 
		
		std::prev_permutation(s1.begin(), s1.end());
		
		std::cout << "prev_permutation: " << s1 << std::endl; //Output: dcba
		
		std::next_permutation(s1.begin(), s1.end());
		
		std::cout << "next_permutation: " << s1 << std::endl; //Output: abcd
		
		return 0;
	}
\end{lstlisting}

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% -------------------------- SECTION: OPERAZIONI NUMERICHE ---------------------------

\newpage

\section{Operazioni Numeriche}

\textsf{\small \textbf{Definizione: } Le \textbf{operazioni numeriche} mettono a disposizione una serie di comuni funzioni matematiche su delle sequenze numeriche ed anche altre.} \\

\textsf{\small Questi operazioni rispetto alle altre, anche se appartenenti alla \emph{Libreria degli Algoritmi} sono definite nell'header \textbf{<numeric>}.} \\

\textsf{\small Queste operazioni sono: \textbf{std::accumulate}, \textbf{std::reduce}, \textbf{std::inner\_product}, \textbf{std::adjacent\_difference}, \textbf{std::partial\_sum}, \textbf{std::exclusive\_scan}, \textbf{std::inclusive\_scan}, \textbf{std::transform\_reduce}, \textbf{std::transform\_exclusive\_scan}, \textbf{std::transform\_inclusive\_scan}, \textbf{std::iota}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <numeric>
	#include <vector>
	#include <iterator>
	
	int main()
	{
		// ESEMPIO ACCUMULATE, REDUCE
		std::vector<int> v = { 24, 77, -6, 14, 22, -90, 12, 3};
		// Lo 0 nel std::accumulate è il valore di partenza, in questo caso parte da un valore di partenza di zero e somma tutti gli elementi del vettore v.
		std::cout << std::accumulate(v.begin(), v.end(), 0) << std::endl; //Output: 56
		
		std::cout << std::reduce(v.begin(), v.end(), 0) << std::endl; //Output: 56
		
		// ESEMPIO ACCUMULATE, REDUCE 2
		std::vector<std::string> s = {"ciao", " a ", "tutti"};
		std::cout << std::accumulate(s.begin(), s.end(), std::string("")); //Output: ciao a tutti 
		
		std::cout << std::reduce(s.begin(), s.end(), std::string("")); //Output: ciao a tutti 
		
		// ESEMPIO INNER\_PRODUCT
		std::vector<int> a = { 7, 3, 2 };
		std::vector<int> b = { 5, 8, 6 };
		
		std::cout << std::inner_product( a.begin(), a.end(), b.begin(), 0) << std::endl; //Output: 71
		
		std::cout << std::inner_product( a.begin(), a.end(), b.begin(), 0, std::minus<int>{}, std::multiplies<int>{}) << std::endl; //Output: -71
		
		// ESEMPIO ADJACENT\_DIFFERENCE, PARTIAL\_SUM
		std::vector<int> vec = { 13, 2, 5, 4, 7, 9};
		std::vector<int> vec2;
		std::vector<int> vec3;
		
		// Fa una differenza tra il secondo e il primo di ogni coppia di elementi della sequenza. 
		std::adjacent_difference( vec.begin(), vec.end(), std::back_inserter( vec2 ));
		
		for(const auto& i : vec2)
		{
			std::cout << i << " ";
		}
		
		std::cout << '\n';
		
		//Output: 13 -11 3 -1 3 2 
		
		std::partial_sum( vec.begin(), vec.end(), std::back_inserter( vec3 ));
		
		for(const auto& i : vec3)
		{
			std::cout << i << " ";
		}
		
		std::cout << '\n';
		
		//Output: 13 15 20 24 31 40
		
		// ESEMPIO INCLUSIVE\_SCAN, EXCLUSIVE\_SCAN
		std::vector<int> v1 = { 12, 3, 7, 8, 44, 9};
		std::vector<int> v2;
		std::vector<int> v3;
		
		// Esegue una operazione di somma di prefisso inclusiva con \emph{binary\_op}.
		std::inclusive_scan( v1.begin(), v1.end(), std::back_inserter( v2 ));
		
		for(const auto& i : v2)
		{
			std::cout << i << " ";
		}
		
		std::cout << '\n';
		
		//Output: 12 15 22 30 74 83
		
		// Esegue una operazione di somma di prefisso esclusiva con \emph{binary\_op}.
		std::exclusive_scan( v1.begin(), v1.end(), std::back_inserter( v3 ), 0);
		
		for(const auto& i : v3)
		{
			std::cout << i << " ";
		}
		
		std::cout << '\n';
		
		//Output: 0 12 15 22 30 74
		
		// ESEMPIO TRANSFORM\_REDUCE
		std::vector<double> xvalues(567, 1.0), yvalues(567, 1.0);
		
		double result = std::transform_reduce(xvalues.begin(), xvalues.end(), yvalues.begin(), 0.0);
		std::cout << result << '\n'; //Output: 567
		
		return 0;
	}
\end{lstlisting}

%TODO: spiegare cosa fanno: la inclusive ed esclusive, transform, ecc..
%TODO: volendo aggiungere esempi sulla transform_exclusive_scan, transform_inclusive_scan.

\subsubsection{Differenza tra std::accumulate vs std::reduce}

\begin{tabular}{|c|c|}
	\hline
	\textbf{accumulate} & \textbf{reduce} \\
	\hline
	\textsf{\small Ordina da sinistra a destra.} & \textsf{\small Non garantisce l'ordine.} \\
	\hline
	\textsf{\small Non ha le \emph{execution policies}.} & \textsf{\small Ha le \emph{execution policies}.} \\
	\hline
\end{tabular}

%TODO: per queste non c'è il ranges sembra..

% --------------- SECTION: OPERAZIONI SU MEMORIA NON INIZIALIZZATA -------------------

\newpage

\section{Operazioni su memoria non inizializzata}

\textsf{\small \textbf{Definizione: } Queste operazioni servono per eseguire operazioni su memorie non inizializzate: \textbf{std::uninitialized\_copy}, \textbf{std::uninitialized\_copy\_n}, \textbf{std::uninitialized\_fill}, \textbf{std::uninitialized\_fill\_n}, \textbf{std::uninitialized\_move}, \textbf{std::uninitialized\_move\_n}, \textbf{std::uninitialized\_default\_construct}, \textbf{std::uninitialized\_default\_construct\_n}, \textbf{std::uninitialized\_value\_construct}, \textbf{std::uninitialized\_value\_construct\_n}, \textbf{std::construct}, \textbf{std::destroy}, \textbf{std::destroy\_at}, \textbf{std::construct\_at}, \textbf{std::destroy\_n}.} \\

\textsf{\small Per quanto riguarda \textbf{std::get\_temporary\_buffer} e \textbf{std::return\_temporary\_buffer} sono state rimosse col \textbf{C++20}.} \break

\textsf{\small Non fanno parte della \emph{Libreria degli Algoritmi}, ma sono comunque molto utili legate ad essa.} \\ %TODO: Oppure fanno parte?

\textsf{\small Sono definite nell'header \textbf{<memory>}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <memory>
	#include <new> // Per std::launder
	#include <cstring>
	#include <string>
	
	class A {
		public:
			int value;
			~A() { std::cout << value << " distrutto\n"; }
	};
	
	int main()
	{
		// ESEMPIO DESTROY, DESTROY\_N, DESTROY\_AT
		// \textbf{alignas} forza l'allineamento al numero di bytes specificato.
		alignas(A) unsigned char buffer[sizeof(A) * 8];
		
		for (int i = 0; i < 8; ++i)
		{
			new(buffer + sizeof(A) * i) A{i}; //costruisco gli oggetti manualmente
		}
		
		// std::launder performa il \emph{Memory Laundering}, questo previene il compilatore dal tracciare da dove hai preso questo oggetto, così evitando ottimizzazioni che potrebbero non essere più applicabili.
		auto ptr = std::launder(reinterpret_cast<A*>(buffer));
		
		std::destroy(ptr, ptr + 8);
		
		// Al posto di std::destroy si potrebbe usare std::destroy\_n: 
		std::destroy_n(ptr, 8);
		
		// Al posto di std::destroy\_n si potrebbe usare std::destroy\_at: 
		for (int i = 0; i < 8; ++i)
		{
			std::destroy_at(ptr + i);
		}
	
		//Output: 0 distrutto
		//Output: 1 distrutto
		//Output: 2 distrutto
		//Output: 3 distrutto
		//Output: 4 distrutto
		//Output: 5 distrutto
		//Output: 6 distrutto
		//Output: 7 distrutto
	
		// ESEMPIO UNINITIALIZED\_DEFAULT\_CONSTRUCT, UNINITIALIZED\_DEFAULT\_CONSTRUCT\_N
		
		class S { 
			public:
				std::string m{ "Valore di default"}; 
		};
		
		constexpr int n {3};
		// \textbf{alignof} restituisce l'allineamento del dato passato come parametro.
		alignas(alignof(S)) unsigned char mem[n * sizeof(S)];
		
		try
		{
			auto first {reinterpret_cast<S*>(mem)};
			auto last {first + n};
			
			std::uninitialized_default_construct(first, last);
			
			for (auto it {first}; it != last; ++it) {
				std::cout << it->m << '\n';
			}
			
			std::destroy(first, last);
		}
		catch(...) // In questo modo con ... (ellissi) prendiamo qualsiasi eccezione.
		{
			std::cout << "Eccezione!\n";
		}
		
		// Da notare che per "i tipi triviali"
		// il uninitialized\_default\_construct generalmente non riempie di zero la data area di memoria non inizializzata.
		int v[] { 1, 2, 3, 4 };
		const int original[] { 1, 2, 3, 4 };
		std::uninitialized_default_construct(std::begin(v), std::end(v));
		
		// Oppure al posto di std::uninitialized\_default\_construct si poteva usare:
		std::uninitialized_default_construct_n(std::begin(v), std::size(v));
		
		std::cout << (std::memcmp(v, original, sizeof(v)) == 0 ? "Non modificato\n" : "Modificato\n");
		// Il risultato non è specificato.
		
		//Output: Valore di default
		//Output: Valore di default
		//Output: Valore di default
		//Output: Non modificato
		
		// ESEMPIO UNINITIALIZED\_VALUE\_CONSTRUCT, UNINITIALIZED\_VALUE\_CONSTRUCT\_N
		class Z { 
			public:
				std::string m{ "Valore di default" }; 
		};
		
		constexpr int n {3};
		alignas(alignof(Z)) unsigned char mem[n * sizeof(Z)];
		
		try
		{
			auto first {reinterpret_cast<Z*>(mem)};
			auto last {first + n};
			
			std::uninitialized_value_construct(first, last);
			
			for (auto it {first}; it != last; ++it) {
				std::cout << it->m << '\n';
			}
			
			std::destroy(first, last);
		}
		catch(...)
		{
			std::cout << "Eccezione!\n";
		}
		
		// Da notare che per "i tipi triviali" il uninitialized\_value\_construct
		// non riempie di zero la data area di memoria non inizializzata.
		int v[] { 1, 2, 3, 4 };
		for (const int i : v) { std::cout << i << ' '; }
		std::cout << '\n';
		std::uninitialized_value_construct(std::begin(v), std::end(v));
		
		// Oppure al posto std::uninitialized\_value\_construct si può usare:
		std::uninitialized_value_construct_n(std::begin(v), std::size(v));
		
		for (const int i : v) { std::cout << i << ' '; }
		std::cout << '\n';
		
		//Output: Valore di default
		//Output: Valore di default
		//Output: Valore di default
		//Output: 1 2 3 4 
		//Output: 0 0 0 0
		
	}
\end{lstlisting}

%TODO: magari approfondire l'argomento in generale, visto che non ho detto molto.
%TODO: approfondire std::launder?

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% ------------------------------ SECTION: OPTIONALS ----------------------------------

\newpage

\section{Optionals}

\textsf{\small \textbf{Definizione: } Gli \textbf{optionals} permettono di definire valori opzionali che per dunque possono esistere come no.} \\

\textsf{\small Questi non fanno parte della \emph{Libreria degli Algoritmi}, ma possono comunque essere utili in correlazione ad essa.} \\

\textsf{\small Per ottenere il valore del \textbf{std::optional} utilizziamo l'operatore \textbf{*}, a meno che } \\

\textsf{\small Sono definiti nel file di intestazione: \textbf{<optional>}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <optional>
	#include <string>
	#include <fstream>
	
	// Al posto di std::nullopt si poteva anche mettere {}.
	// Quelli nell'uguale sono i valori di default se i parametri non vengono passati quando viene chiamata la funzione.
	int foo(int x, std::optional<int> y = std::nullopt, int z = 0)
	{
		return x * y.value_or( 17 ) + z;
	}

	// Funzione che ritorna std::pair con  std::optional
	std::pair<bool, std::string> loadFile()
	{
		std::ifstream file{ "test.txt" };
		if( file )
		{
			return { true, std::string{ 
					std::istreambuf_iterator{ file },
					std::istreambuf_iterator<char>{}
			}};
		}
		return { false, {} };
	}
	
	int main()
	{
		// ESEMPIO OPTIONAL
		struct Point {
			float x, y;
			Point(float x, float y) : x( x ), y( y ) {} 
		};
	
		// Questi sono tutti tipi di optionals empty (vuoti).
		std::optional<int> oEmpty;
		std::optional<int> oEmpty2{};
		std::optional<int> oEmpty3 = {};
		std::optional<float> oEmpty4 = std::nullopt;
		
		// Qui assegniamo un valore direttamente
		std::optional<int> oInt = 34;
		std::optional<int> oInt2( 9 );
		std::optional oP( Point{ 7.2f, 4.1f } );
		
		// make\_optional
		auto oDouble = std::make_optional( 3.69 );
		auto oPoint = std::make_optional<Point>( 3.2f, 1.4f);
		
		// emplacement
		std::optional<Point> oEmpty5;
		oEmpty5.emplace( 4.5f, 1.7f );
		
		// in\_place
		std::optional<Point> oEmpty6{ std::in_place, 2.2f, 4.4f };
		
		std::cout << *oInt << std::endl; //Output: 34
		
		// Si può evitare di mettere il * per fare i paragoni oppure lo si può anche mettere.
		if(oInt > oInt2)
		{
			std::cout << *oInt << " è maggiore di " << *oInt2 << std::endl;
		}
	
		//Output: 34 è maggiore di 9
	
		// Nelle funzioni
	
		std::cout << foo(5, 23, 8) << std::endl; //Output: 123
		
		std::cout << foo(5, {}, 8) << std::endl; //Output: 93
		
		std::cout << foo(5, {}) << std::endl; //Output: 85
		
		std::cout << foo(5, 23) << std::endl; //Output: 115
		
		return 0; 
	}
\end{lstlisting}

% ------------------------- SECTION: EXECUTION POLICIES ------------------------------

\newpage

\section{Execution Policies}

\textsf{\small \textbf{Definizione: } Le \textbf{execution policies} servono per l'esecuzione parallelizzata di un programma. } \\

\textsf{\small La \emph{parallelizzazione} è quando molteplici calcoli vengono eseguiti simultaneamente da più \emph{threads}. } \break

\textsf{\small Queste non fanno parte della \emph{Libreria degli Algoritmi}, ma possono essere utili soprattutto se si eseguono programmi con le threads.} \\

\textsf{\small Alcuni degli algoritmi della \emph{Libreria degli Algoritmi} usufruiscono delle \textbf{execution policies}, quindi può essere utile fare chiarezza su quest'ultime.} \\

\textsf{\small Le \textbf{execution policies} sono definite nell'header \textbf{<execution>}.} \\

\textsf{\small Utilizzeremo questa classe \emph{Timer} per tenere traccia di quanto tempo è stato necessario per eseguire una porzione di codice.} \\

\begin{lstlisting}
	// Nell'header file: Timer.h
	#pragma once
	#include <chrono>
	
	class Timer {
		public:
			Timer() noexcept;
			
			float mark() noexcept;
			
			float peek() const noexcept;
			
		private:
			std::chrono::steady_clock::time_point last;
	};

	// Nel file di implementazione: Timer.cpp
	#include "Timer.h"
	
	Timer::Timer() noexcept
	{
		last = std::chrono::steady_clock::now();
	}
	
	float Timer::mark() noexcept
	{
		const auto old = last;
		last = std::chrono::steady_clock::now();
		const std::chrono::duration<float> frameTime = last - old;
		return frameTime.count();
	}
	
	float Timer::peek() const noexcept
	{
		return std::chrono::duration<float>( std::chrono::steady_clock::now() - last).count();
	}
\end{lstlisting}

\textsf{\small Un primo esempio dell'efficienza delle \textbf{execution policies}: } \\

\begin{lstlisting}
	#include <iostream>
	#include <execution>
	#include <vector>
	#include <random>
	#include <algorithm>
	#include <chrono>
	#include "Timer.h"

	void test()
	{
		std::mt19937 rne{ 72 };
		std::uniform_real_distribution<float> d(-10., 10. );
		auto rng = [&rne, &d]() {return d( rne ); };
		
		constexpr size_t n = 60000000;
		std::vector<float> v( n );
		std::generate( v.begin(), v.end(), rng ); 
		
		Timer timer;
		timer.mark();
		std::sort( v.begin(), v.end() );
		auto t = timer.peek();
		
		std::cout << t << std::endl;
	}
	
	void testWithExecPolicies()
	{
		std::mt19937 rne{ 72 };
		std::uniform_real_distribution<float> d(-10., 10. );
		auto rng = [&rne, &d]() {return d( rne );};
		
		constexpr size_t n = 60000000;
		std::vector<float> v( n );
		std::generate( v.begin(), v.end(), rng ); 
		
		Timer timer;
		timer.mark();
		std::sort( std::execution::par, v.begin(), v.end() );
		auto t = timer.peek();
		
		std::cout << t << std::endl;
	}
	
	int main()
	{
		test(); //Output: ~6sec tempo diverso per tutti ma maggiore rispetto all'altro test. (l'output è sempre diverso, in base al tuo computer, alla sequenza, ecc..)
		
		testWithExecPolicies(); //Output: ~1.3sec tempo diverso per tutti, ma minore rispetto all'altro test. (l'output è sempre diverso, in base al tuo computer, alla sequenza, ecc..)
		
		return 0;
	}
\end{lstlisting}

%TODO: errori nei compilatori: Mi dava un errore nell'inclusione di <execution> indicando che mancasse una libreria ttb/blocked_range, oppure che mancasse proprio l'header <execution>.

\textsf{\small Con \emph{par} eseguiamo la parte di codice indicata in modo \emph{parallelo}.} \\

\begin{lstlisting}
	#include <iostream>
	#include <execution>
	#include <vector>
	#include <algorithm>
	#include "Timer.h"
	
	void test()
	{
		std::mt19937 rne{ 54 };
		std::uniform_real_distribution<double> d( 1., 10. ); // I valori negativi potrebbero causare dei problemi.
		auto rng = [&rne, &d]() { return d( rne ); };
		
		constexpr size_t n = 30000000;
		std::vector<double> v( n );
		std::generate( v.begin(), v.end(), rng );
		
		Timer timer;
		timer.mark();
		
		std::transform( std::execution::par, v.begin(), v.end(), v.begin(), [](double a)
		{
			const auto b = std::acos( 1.0 / a);
			return std::pow(b, b);
		});
		auto t = timer.peek();
		
		std::cout << t << std::endl;
	}
	
	int main()
	{
		test();
		return 0;
	}
\end{lstlisting}

\textsf{\small Un terzo esempio, in cui però senza la \emph{mutua esclusione} (mutex) per evitare la \emph{race condition} il programma non darebbe lo stesso risultato. } \\

\textsf{\small La \emph{race condition} è quando due \emph{threads} (flussi di istruzioni che può essere eseguito in modo concorrente) arrivano entrambe alla stessa variabile ed entrambe cambiano il valore di essa nello stesso momento. Quindi una stessa variabile di valore 9 potrebbe essere aumentata di 1 da due \emph{threads} portando il valore di suddetta variabile a 10, al posto di 11.} \\

\begin{lstlisting}
	#include <iostream>
	#include <execution>
	#include <vector>
	#include <thread>
	#include <mutex>
	#include <algorithm>
	#include "Timer.h"
	
	void testWithoutMutex()
	{
		std::mt19937 rne{ 72 };
		std::uniform_real_distribution<double> d( 1., 10. );
		auto rng = [&rne, &d]() { return d( rne ); };
		
		constexpr size_t n = 30000000;
		std::vector<double> v( n );
		std::vector<double> q( n );
		std::generate( v.begin(), v.end(), rng );
		
		Timer timer;
		timer.mark();
		
		std::for_each( v.begin(), v.end(), [&rng](double& a))
		{
			a = rng();
		});
		auto t1 = timer.peek();
		
		rne.seed( 72 );
		
		timer.mark();
		std::for_each( std::execution::par, v.begin(), v.end(), [&rng](double& a))
		{
			a = rng();
		});
		auto t2 = timer.peek();
		
		std::sort( std::execution::par, v.begin(), v.end());
		std::sort( std::execution::par, q.begin(), q.end());
		
		std::cout << std::boolalpha << (v == q) << std::endl; //Output: viene false se non li ordini (col sort), ma senza la mutex verrebbe comunque false
	}

	void testWithMutex()
	{
		std::mt19937 rne{ 72 };
		std::uniform_real_distribution<double> d( 1., 10. );
		auto rng = [&rne, &d]() { return d( rne ); };
		
		constexpr size_t n = 30000000;
		std::vector<double> v( n );
		std::vector<double> q( n );
		std::generate( v.begin(), v.end(), rng );
		
		Timer timer;
		timer.mark();
		
		std::for_each( v.begin(), v.end(), [&rng](double& a))
		{
			a = rng();
		});
		auto t1 = timer.peek();
		
		rne.seed( 72 );
		std::mutex mutex;
		
		timer.mark();
		std::for_each( std::execution::par, v.begin(), v.end(), [&rng, &mutex](double& a))
		{
			// In questo modo con la mutex, solo una thread alla volta ha accesso alla variabile e può modificarla, poi quando ha finito rilascia la risorsa e anche le altre threads possono lockare la variabile ed utilizzarla.
			std::lock_guard<std::mutex> lock(mutex);
			a = rng();
		});
		auto t2 = timer.peek();
		
		std::cout << std::boolalpha << (v == q) << std::endl; //Output: false (non sono la stessa sequenza, ma sono gli stessi numeri è per questo che riordinandoli ci da true poi)
		
		std::sort( std::execution::par, v.begin(), v.end());
		std::sort( std::execution::par, q.begin(), q.end());
		
		std::cout << std::boolalpha << (v == q) << std::endl; //Output: true
	}
	
	int main()
	{
		testWithoutMutex();
		
		testWithMutex();
		return 0;
	}
\end{lstlisting}

\textsf{\small Per la questione del \emph{Multithreading} servirebbe un intero capitolo a parte per spiegare, approfondire il funzionamento, cosa sono i \emph{threads}, cos'è la \emph{mutex}, cosa sono le \emph{condition variables}, i \emph{semaphore}, eccetera..} \\

%TODO: casomai scrivessi il capitolo sul Multithreading, allora aggiungere la \pageref qui a quel capitolo.

\fleuron

\textsf{\small Per tutte queste operazioni c'è un equivalente per \emph{ranges} del C++20 a pag. \pageref{ranges}} \\

% -------------------------------- SECTION: C++20 ------------------------------------

\newpage

%TODO: metterlo in un capitolo a parte?

\section{C++20}

\textsf{\small \textbf{Definizione: } Il \textbf{C++20} ha introdotto nel linguaggio diverse funzionalità utili agli algoritmi, formando così la versione \emph{Constrained Algorithms} della maggior parte degli algoritmi nel namespace \textbf{std::ranges}. } \\

\textsf{\small Questa versione del linguaggio ha introdotto una serie di funzionalità, alcune di queste sono: \textbf{Ranges}, \textbf{Concepts}, \textbf{Modules}, \textbf{Coroutine} e altro ancora..} \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1.2\textwidth, height=1.2\textheight, keepaspectratio]{./imgs/TimelineCpp20_3.png}
	\caption{C++20 Timeline}
	\label{fig:TimelineCpp20_3}
\end{figure}

\subsection{Ranges}

\label{ranges}

%TODO: ranges view

\textsf{\small \textbf{Definizione: } I \textbf{ranges} sono, concettualmente, un paio di iteratori, all'inizio ed alla fine della sequenza ( o una \emph{sentinel} sentinella in certi casi).} \\

\textsf{\small I \textbf{ranges} velocizzano la chiamata alle funzioni della \emph{Libreria degli Algoritmi} in cui al posto di dover passare un iteratore (.begin(), .end()) con i \textbf{ranges} possiamo semplicemente passare l'oggetto, la sequenza stessa.} \break

\subsubsection{Tipi di Ranges}

\textsf{\small I ranges possono essere \emph{input ranges} (possono essere letti), \emph{output ranges} (ci si può scrivere) o entrambi.} \\

\textsf{\small Gli \emph{input ranges}: } \\

\begin{tabular}{|c|c|}
	\hline
	\textbf{Concetto} & \textbf{Descrizione} \\
	\hline
	\textsf{\small \textbf{std::ranges::input\_range}} & \textsf{\small può essere iterato } \\
	\textsf{\small \textbf{}} & \textsf{\small dall'inizio alla fine almeno una volta.} \\
	\hline
	\textsf{\small \textbf{std::ranges::forward\_range}} & \textsf{\small può essere iterato } \\
	\textsf{\small \textbf{}} & \textsf{\small dall'inizio alla fine molteplici volte.} \\
	\hline
	\textsf{\small \textbf{std::ranges::bidirectional\_range}} & \textsf{\small può muoversi all'indietro con \textbf{- -}.} \\
	\hline
	\textsf{\small \textbf{std::ranges::random\_access\_range}} & \textsf{\small si possono saltare gli elementi con \textbf{[]}.} \\
	\hline
	\textsf{\small \textbf{std::ranges::contiguous\_range}} & \textsf{\small gli elementi vengono } \\
	\textsf{\small \textbf{}} & \textsf{\small memorizzati consecutivamente in memoria.} \\
	\hline
\end{tabular}

\textsf{\small Questi concetti sono derivati direttamente dai rispettivi concetti negli iteratori.} \\

\textsf{\small Ci sono anche dei \textbf{ranges} che sono indipendenti dall'\emph{input} o \emph{output}, per esempio \textbf{std::ranges::sized\_range} che richiede che lo spazio di un range sia recuperabile da \textbf{std::ranges::size()}.} \\

\textsf{\small Le \textbf{ranges::views} sono dei \textbf{ranges} che trasformano il \textbf{range} attraverso degli algoritmi o delle operazioni. Le \textbf{views} non possiedono alcuna data eccetto il loro algoritmo e il tempo di costruzione, distruzione o copiatura non dovrebbe dipendere dal numero di elementi che rappresentano.} \\

\textsf{\small I \textbf{ranges} sono definiti nel file di intestazione: \textbf{<ranges>}.} \\

\subsubsection{Operazioni su sequenze non modificabili}

\label{ranges_seq_non_modificabili}

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <string_view>
	#include <ranges>
	
	// Palindromo: sequenza di caratteri che letta al contrario rimane invariata.
	constexpr bool isPalindrome(const std::string_view s)
	{
		namespace views = std::views;
		auto forward = s | views::take(s.size() / 2);
		auto backward = s | views::reverse | views::take(s.size() / 2);
		return std::ranges::equal(forward, backward);
	}
	
	void test(const std::string_view s)
	{
		std::cout << s << (isPalindrome(s) ? " è" : " non è") << " un palindromo\n";
	}
	
	int main()
	{
		// ESEMPIO RANGES::EQUAL
		test("radar"); //Output: radar è un palindromo
		test("ciao"); //Output: ciao non è un palindromo
		
		// ESEMPIO RANGES::STARTS\_WITH
		std::cout << std::boolalpha << std::ranges::starts_with("luce", "lucertola") << '\n'; //Output: true
		std::cout << std::boolalpha << std::ranges::starts_with("const", "cast") << '\n'; //Output: false
		
		// ESEMPIO RANGES::ENDS\_WITH
		std::cout << std::boolalpha << std::ranges::ends_with("ter", "computer") << '\n'; //Output: true
		std::cout << std::boolalpha << std::ranges::ends_with("asse", "casse") << '\n'; //Output: true
		std::cout << std::boolalpha << std::ranges::ends_with("ada", "scheda") << '\n'; //Output: false
		return 0;
	}
\end{lstlisting}

\subsubsection{Operazioni su sequenze modificabili}

\label{ranges_seq_modificabili}

\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <ranges>
	
	int main()
	{
		// ESEMPIO RANGES::VIEWS::TRANSFORM
		namespace rn = std::ranges;
		namespace vi = std::ranges::views;
		
		std::vector<int> numbers = { 7, 8, 1, 2, 5, 3 };
		
		auto result = numbers | vi::filter([](int n) {return n % 2 == 0; })
		| vi::transform([](int n) {return n * 2; });
		
		for(const int& n : result)
		{
			std::cout << n << ' ';
		}
	
		//Output: 16 4
	
		return 0;
	}
\end{lstlisting}

\subsubsection{Operazioni su Partizioni}
\subsubsection{Operazioni di Ordinamento}
\subsubsection{Operazioni su ricerca binaria}
\subsubsection{Operazioni sugli Insiemi}
\subsubsection{Operazioni su Heap}
\subsubsection{Operazioni su Min/Max}
\subsubsection{Operazioni su Permutazioni}
\subsubsection{Operazioni numeriche}
\subsubsection{Operazioni su memoria non inizializzata}
\subsubsection{Tipi di Ritorno}

\newpage

\subsection{Concepts}

%TODO: <concepts>

\textsf{\small \textbf{Definizione: } } \\

\newpage

\subsection{Modules}

\textsf{\small \textbf{Definizione: } } \\

\newpage

\subsection{Coroutines}

%TODO: <coroutine>

\textsf{\small \textbf{Definizione: } } \\

%TODO: ranges, concepts, constrained algorithms, coroutines, template parameter list, modules, ecc..
%TODO: non tutte queste c'entrano con la libreria degli algoritmi, le altre le potrei trattare nel capitolo 'Concetti Avanzati' (visto che è anche il più corto)
%TODO: tipo la libreria <coroutine>, <concepts>, ecc..

\begin{comment}
\begin{lstlisting}
	#include <iostream>
	#include <algorithm>
	#include <vector>
	#include <ranges>
	
	int main()
	{
		return 0;
	}
\end{lstlisting}
\end{comment}

% ------------------------------ FINE CAPITOLO ---------------------------------------